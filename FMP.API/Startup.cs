/// <summary>
/// Schlumberger Private
/// Copyright 2018 Schlumberger.All rights reserved in Schlumberger
/// authored and generated code(including the selection and arrangement of
/// the source code base regardless of the authorship of individual files),
/// but not including any copyright interest(s) owned by a third party
/// related to source code or object code authored or generated by
/// non-Schlumberger personnel.
/// This source code includes Schlumberger confidential and/or proprietary
/// information and may include Schlumberger trade secrets.Any use,
/// disclosure and/or reproduction is prohibited unless authorized in
/// writing.
/// </summary>

using System;
using FMP.API.Helper.DependencyHelper;
using FMP.Common;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Authorization;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Serilog;
using Microsoft.Extensions.Logging;
using ILogger = Serilog.ILogger;
using static Serilog.Log;
using FMP.API.Helper;
using Microsoft.Extensions.Hosting;
using Swashbuckle.AspNetCore.SwaggerUI;

#pragma warning disable 1591

namespace FMP.API
{
    /// <summary>
    ///     Startup class
    /// </summary>
    public class Startup
    {
        /// <summary>
        ///     Startup class constructor
        /// </summary>
        /// <param name="configuration">application config</param>
        /// <param name="env">hosting env</param>
        public Startup(IConfiguration configuration, IWebHostEnvironment env)
        {
            Configuration = StartupExtension.GetConfiguration(configuration, env);
            HostingEnvironment = env;
        }

        public IConfiguration Configuration { get; }

        protected ILogger Logger;

        /// <summary>
        ///     The microservice's hosting environment.
        /// </summary>
        protected IWebHostEnvironment HostingEnvironment { get; }

        /// <summary>
        ///     This method gets called by the runtime. Use this method to add services to the container.
        /// </summary>
        /// <param name="services">service collection instance</param>
        public void ConfigureServices(IServiceCollection services)
        {
            AddSerilog(services);

            //services.AddMvc();
            services.AddControllers();
            var origins = Configuration["Origins"].Split(',');

            services.AddCors(options =>
            {
                options.AddPolicy("CorsPolicy",
                    builder => builder.SetIsOriginAllowedToAllowWildcardSubdomains()
                        .WithOrigins(origins)
                        .AllowAnyMethod()
                        .AllowAnyHeader()
                        .AllowCredentials().Build());
            });

            // Enable Authorize Setting
            if (Convert.ToBoolean(Configuration["EnableAuthorize"]) == false)
                services.AddMvc(
                    config => { config.Filters.Add(new AllowAnonymousFilter()); });

            // Global Exception Filter
            //services.AddMvc(
            //    config => { config.Filters.Add(typeof(HttpGlobalExceptionFilter)); }
            //);
            services.AddHttpContextAccessor();
            DependencyHelper.RegisterDBConfiguration(Configuration, services);
            DependencyHelper.RegisterRepositories(services);
            DependencyHelper.RegisterServices(services);

            #region Authentication Configure

            services.AddAuthentication(opt =>
            {
                opt.DefaultScheme = "Bearer";
                opt.DefaultAuthenticateScheme = "Bearer";
            }).AddIdentityServerAuthentication(options =>
            {
                options.Authority = Configuration["IdentityUrl"];
                options.RequireHttpsMetadata = false;
                options.ApiName = Configuration["ApiName"];
            });

            #endregion

            // Enable Swagger
            services.EnableSwagger(Configuration, System.Reflection.Assembly.GetExecutingAssembly().GetName().Name);
            services.AddFMPHealthCheck(Configuration);
        }

        /// <summary>
        ///     This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        /// </summary>
        /// <param name="app">ApplicationBuilder instance</param>
        public void Configure(IApplicationBuilder app)
        {
            Logger.Debug("Configure start");

            var connection = Configuration.GetSection("MongoConnection:ConnectionString").Value;
            Logger.Debug("connection str=" + connection);
            var db = Configuration.GetSection("MongoConnection:Database").Value;
            //Logger.Debug("connection str=" + connection);
            //Logger.Debug("database str=" + db);

            app.UseStaticFiles();
            app.UseCors("CorsPolicy");

            Logger.Debug("EnvironmentName={0}", HostingEnvironment.EnvironmentName);

            if (HostingEnvironment.IsDevelopment() || HostingEnvironment.IsEnvironment("Local")) app.UseDeveloperExceptionPage();

            app.UseAuthentication();
            // Enable middleware to serve generated Swagger as a JSON endpoint.
            app.UseSwagger();

            // Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.), 
            // specifying the Swagger JSON endpoint.
            app.UseSwaggerUI(c =>
            {
                c.SwaggerEndpoint("/swagger/" + Configuration["Version"] + "/swagger.json", Configuration["Title"]);
                c.InjectStylesheet("/swagger/css/custom-style.css");
                c.OAuthConfigObject = new OAuthConfigObject
                {
                    AppName = Configuration.GetValue<String>("SwaggerAppName"),
                    ClientId = Configuration.GetValue<String>("SwaggerClientId"),
                    UsePkceWithAuthorizationCodeGrant = true,
                    ClientSecret = Configuration.GetValue<String>("SwaggerClientSecret")
                };
            });

            //app.UseMvc();
            app.UseRouting();
            app.UseAuthentication();
            app.UseAuthorization();
            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllers();
            });

            app.UseFMPHealthCheck();
            Logger.Debug("Configure end");
        }

        private void AddSerilog(IServiceCollection services)
        {
            var originalGlobalLogger = Log.Logger;
            try
            {
                services.AddLogging(loggingBuilder =>
                {
                    if (HostingEnvironment.IsDevelopment() || HostingEnvironment.IsEnvironment("Local"))
                    {
                        loggingBuilder.AddConsole();
                        loggingBuilder.AddDebug();
                    }

                    // create the logger that can be used throughout startup code
                    var logger = new LoggerConfiguration().ReadFrom.Configuration(Configuration).CreateLogger().ForContext(GetType());
                    logger.Information("Logger created");

                    // reset our global logger, which has no context, but at least it has the configuration we want.
                    // future contextual loggers will be based off of this one...
                    Log.Logger = logger;

                    // ...for example, we can now set the contextual logger for the startup class
                    Logger = Log.Logger.ForContext(GetType());

                    loggingBuilder.AddSerilog(dispose: true);
                    Logger.Information("Serilog initialized from configuration");
                });

                services.AddSingleton(c => Log.Logger);
            }
            catch (Exception e)
            {
                Error(e, "Could not initialize serilog from configuration; using original global logger");

                // well, we're stuck with what we started with
                Log.Logger = originalGlobalLogger;
                throw;
            }
        }
    }
}