/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */
import * as LO from 'lodash';
import { Site } from './siteDetails';
import { FMPHelper, UnitOfMeasurements } from 'src/Constants/helpers';
import { IUnitsOfMeasurement } from 'src/Constants/application';
import { MateoQueue } from './mateoQueue';
import { Claim } from './role';

//#region Interface for Mateo User Profile API Service

/**
 * IUserProfile Interface
 * Mapped to the User API returned data (For the logged in user)
 * @export
 * @interface IUserProfile
 */
export interface IUserProfile {
    firstName: string;
    lastName: string;
    ldapAlias: string;
    email: string;
    ginNumber: string;
    active: boolean;
    activeCMMS: string;
    role: IRole[];
    selectedUserRole: Role;
    lastReleaseNoteDismiss: number;
}


/**
 * IRole Interface
 * Mapped to the Role returned from MATEO - as part of the user profiles api call
 * @export
 * @interface IRole
 */
export interface IRole {
    name: string;
    description: string;
    profile: IProfile[];
    link: ILink;
}


/**
 * IProfile Interface
 * Mapped to the Profiles / Sites / Worklocations returned from the user profiles api call
 * @export
 * @interface IProfile
 */
export interface IProfile {
    profileId?: string;
    competencyProfile?: string;
    embargoLocationFlag: boolean;
    labourHours: string;
    organization: string;
    segment: string;
    workLocation: string;
    // workLocationName: string;
    siteName?: string;
}


/**
 * ILink Interface
 *
 * @export
 * @interface ILink
 */
export interface ILink {
    href: string;
    rel: string;
    type: string;
}
//#endregion


//#region Classes for Mateo User Profile API Service

/**
 * User Profile Class
 * Used for managinf user profiles
 * @export
 * @class UserProfile
 * @implements {IUserProfile}
 */
export class UserProfile implements IUserProfile {
    constructor(_user: IUserProfile) {
        if (_user) {
            this.firstName = _user.firstName;
            this.lastName = _user.lastName;
            this.ldapAlias = _user.ldapAlias;
            this.email = _user.email;
            this.ginNumber = _user.ginNumber;
            this.active = _user.active;
            // this.refreshInterval = _user.refreshInterval;
            this.role = _user.role ? _user.role.map(r => new Role(r)) : [];
            this.selectedUserRole = _user.selectedUserRole;
            this.lastReleaseNoteDismiss = _user.lastReleaseNoteDismiss;
        }
    }

    firstName: string;
    lastName: string;
    ldapAlias: string;
    email: string;
    ginNumber: string;
    active: boolean;
    activeCMMS: string;
    role: Role[];
    selectedUserRole: Role;
    refreshInterval: number;
    // userProfilePreferences: UserPreference;
    isAdmin: boolean;
    isDeveloper: boolean;
    lastReleaseNoteDismiss: number;

    /**
     * selectRole getter manages to mark the currently selected role as selected
     * marking other roles as unselected.
     * @param {Role} _role
     * @memberof UserProfile
     */
    selectRole(_role: Role) {
        // Intially Make all roles as false and then the selected one true.
        this.role.forEach(r => r.isSelected = false);
        _role.isSelected = true;
    }


    /**
     * seletedRole returns the selected role from the user profile selection
     *
     * @readonly
     * @type {Role}
     * @memberof UserProfile
     */
    get seletedRole(): Role {
        if (this.role && this.role.length > 0) {
            const currRole = this.role.find(r => r.isSelected === true);
            return currRole ? currRole : this.role[0];
        }
        return null;
    }
}


/**
 * Role Class is used for managing the roles for the user
 *
 * @export
 * @class Role
 * @implements {IRole}
 */
export class Role implements IRole {
    constructor(_role: IRole) {
        if (_role) {
            this.name = _role.name;
            this.fmpRoleName = _role.name;
            this.description = _role.description;
            // this.claims = _role.claims;
            if (_role.profile) {
                this.profile = _role.profile.map(p => new Profile(p));
            }
        }
    }

    name: string;
    fmpRoleName: string;
    description: string;
    profile: Profile[];
    link: Link;

    isSelected = false;
    isInitLoad = false;
    claims: Claim[];
    assignedClaims: String;

    /**
     * getSelectedtWorkLocationName getter returns the selected worklocations for the role
     *
     * @readonly
     * @type {string}
     * @memberof Role
     */
    get getSelectedtWorkLocationName(): string {
        return this.seletedWorkLocations.length > 1 ? 'Site(s)' :
            (this.seletedWorkLocations.length === 1 ?
                this.seletedWorkLocations[0].segmentWorkLocation : this.profile[0].segmentWorkLocation);
    }


    /**
     * hasSelectedWorkLocation returns if the role has any selected work location
     *
     * @readonly
     * @type {boolean}
     * @memberof Role
     */
    get hasSelectedWorkLocation(): boolean {
        // return LO.some<Profile>(this.profile, p => p.isSelected);
        return LO.some<Profile>(this.profile, p => p.isSelected);
    }


    /**
     * seletedWorkLocations returns the selected work location for the role.
     *
     * @readonly
     * @type {Profile[]}
     * @memberof Role
     */
    get seletedWorkLocations(): Profile[] {
        // return LO.filter<Profile>(this.profile, p => p.isSelected);
        return LO.filter<Profile>(this.profile, p => p.isSelected);
    }

    get getAssignedClaims(): String {
        return this.claims ? this.claims.map(c => c.description).join(',\n') : 'No Claims Configured.';
    }
}


/**
 * Profile Class manages the worklocations / sites
 *
 * @export
 * @class Profile
 * @implements {IProfile}
 */
export class Profile implements IProfile {
    constructor(_profile: IProfile) {
        if (_profile) {
            this.profileId = _profile.profileId;
            this.competencyProfile = _profile.competencyProfile;
            this.embargoLocationFlag = _profile.embargoLocationFlag;
            this.labourHours = _profile.labourHours;
            this.organization = _profile.organization;
            this.segment = _profile.segment;
            this.workLocation = _profile.workLocation;
            // this.workLocationName = _profile.workLocationName;
            this.segmentWorkLocation = _profile.segment + ' - ' + _profile.workLocation;
            this.siteName = _profile.siteName;
            this.isSelected = false;
            this.isSelectedModified = false;
        }
    }

    profileId?: string;
    competencyProfile?: string;
    embargoLocationFlag: boolean;
    labourHours: string;
    organization: string;
    segment: string;
    workLocation: string;
    // workLocationName: string;
    segmentWorkLocation: string;
    siteName?: string;

    isSelected: boolean;
    isSelectedModified: boolean;
    siteDetails: Site;
}

export class Link implements ILink {
    constructor(_link: ILink) {
        this.href = _link.href;
        this.rel = _link.rel;
        this.type = _link.type;
    }
    href: string;
    rel: string;
    type: string;
}
//#endregion

//#region Interface and Model for User Profile Mongo DB Table

/**
 * IUserPreference Interface is used for managing the saved user preferences.
 *
 * @export
 * @interface IUserPreference
 */
export interface IUserPreference {
    profileID: number;
    userID: string;
    lastApplicationName: string;
    roleName: string;
    activeLocations: string;
    isActive: boolean;
    refreshInterval: number;
    lastReleaseNoteDismiss: number;
    savedPreference: ISavedPreference;
    isAdmin: boolean;
    isDeveloper: boolean;
}

export interface ISavedPreference {
    unitOfMeasurement: string;
}


/**
 * UserPreference class is used for managing the saved user preferences.
 *
 * @export
 * @class UserPreference
 * @implements {IUserPreference}
 */
export class UserPreference implements IUserPreference {
    constructor(_preference: IUserPreference) {
        if (_preference) {
            this.profileID = _preference.profileID;
            this.userID = _preference.userID;
            this.lastApplicationName = _preference.lastApplicationName;
            this.roleName = _preference.roleName;
            this.activeLocations = _preference.activeLocations;
            this.isActive = _preference.isActive;
            this.refreshInterval = _preference.refreshInterval;

            this.savedPreference = new SavedPreference(_preference.savedPreference);
            this.isAdmin = _preference.isAdmin;
            this.isDeveloper = _preference.isDeveloper;
            this.lastReleaseNoteDismiss = _preference.lastReleaseNoteDismiss;
        }
    }

    profileID: number;
    userID: string;
    lastApplicationName: string;
    roleName: string;
    activeLocations: string;
    isActive: boolean;
    refreshInterval: number;
    savedPreference: SavedPreference;
    isAdmin: boolean;
    isDeveloper: boolean;
    lastReleaseNoteDismiss: number;
}


/**
 * SavedPreference manages the saved user preferences for the time zone and unit of measurement.
 *
 * @export
 * @class SavedPreference
 * @implements {ISavedPreference}
 */
export class SavedPreference implements ISavedPreference {
    constructor(_savedpreference: ISavedPreference) {
        this.timeZone = FMPHelper.CurrentTimeZoneWithOffset;
        if (_savedpreference) {
            this.unitOfMeasurement = _savedpreference.unitOfMeasurement;
        }
    }
    timeZone: string;
    unitOfMeasurement: string;

    get UOMDetails(): IUnitsOfMeasurement {
        return UnitOfMeasurements[this.unitOfMeasurement];
    }
}
//#endregion

// Data Model and View Model for User Profile data

/**
 * UserProfileDataModel manages the user profile data and saved preferences
 *
 * @export
 * @class UserProfileDataModel
 */
export class UserProfileDataModel {
    public LDAP: string;
    public user: UserProfile;
    public preference: SavedPreference;

    UserProfileMateoURLCollection: UserProfileRequestModel[];

    /**
     * Checks if the data fetch for the segments is in progress and returns appropiate (true or false) value.
     *
     * @readonly
     * @type {boolean}
     * @memberof UserProfileDataModel
     */
    get isUserProfileDataFetchInProgress(): boolean {
        let returnValue = false;
        if (this.UserProfileMateoURLCollection && this.UserProfileMateoURLCollection.length > 0) {
            returnValue = this.UserProfileMateoURLCollection.some(q => q.QueueItem && q.QueueItem.HasToProcess);
        }
        return returnValue;
    }
}


/**
 *  UserProfileViewModel stores the user profile data.
 *
 * @export
 * @class UserProfileViewModel
 */
export class UserProfileViewModel {
    constructor(_data: UserProfileDataModel) {
        this.data = _data;
    }
    public roleBound: Role;
    public data: UserProfileDataModel;
}
// End


/**
 * UserProfileRequestModel is the request model for the user profile api call.
 *
 * @export
 * @class UserProfileRequestModel
 */
export class UserProfileRequestModel {
    userldap: string;
    productLine: string;
    QueueItem: MateoQueue<IUserProfile[] | IUserProfile>;
}

// To do - Remove below code and its reference/usage from application


/**
 * UserRoleSiteDataModel is the data model for the selected role and site(s)
 *
 * @export
 * @class UserRoleSiteDataModel
 */
export class UserRoleSiteDataModel {
    userID: string;
    roleName: string;
    firstName: string; // must include these here because this object us used to insert the first users profile!
    lastName: string; // must include these here because this object us used to insert the first users profile!
    activeLocations: string;
    refreshInterval: number;
    userProfiles: IUserProfile[] = [];
}

/**
 * UserRoleSiteViewModel is the view model for the selected role and site(s)
 *
 * @export
 * @class UserRoleSiteViewModel
 */
export class UserRoleSiteViewModel {
    constructor(_data: UserRoleSiteDataModel) {
        this.data = _data;
    }
    public data: UserRoleSiteDataModel;
}

export interface User {
    gin: number;
    alias: string;
    FirstName: string;
    LastName: string;

}
