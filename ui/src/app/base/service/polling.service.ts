/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */
import { HttpClient, HttpResponse, HttpHeaders } from '@angular/common/http';

import { Injectable, NgZone } from '@angular/core';
import { interval } from 'rxjs/internal/observable/interval';
import { startWith, switchMap, map, catchError } from 'rxjs/operators';
import { Polling } from '../models/polling';
import { DataService } from './data.service';
import { Observable, Subject } from 'rxjs';
import { LoggerService } from './logger.service';
import {
  MateoQueue,
  MateoQueueStatus,
  MateoQueueType,
} from '../models/mateoQueue';
import { TranslateService } from '@ngx-translate/core';
import { ErrorService } from './error.service';
import { AppTranslateService } from '../../app.translate.service';

@Injectable({
  providedIn: 'root',
})
export class PollingService extends DataService {
  private dummyMonitorObservable: Subject<any>;
  private retryExceededResponse;
  private language = 'en';
  private tcoErrorData;
  private numberOfTry = 60;

  constructor(
    protected http: HttpClient,
    public loggerService: LoggerService,
    private angularZone: NgZone,
    private translate: TranslateService,
    private appTranslateService: AppTranslateService,
    private errorService: ErrorService,
  ) {
    super('PollingService', '', http, loggerService);
    this.dummyMonitorObservable = new Subject<any>();
    this.language = this.appTranslateService.getCurrentLanguge();
    this.appTranslateService.changeDefaultLanguage(this.language);
    this.translate.get('CONTEXTHELP.ACTIVITYMONITOR.ERROR').subscribe(res => {
      this.tcoErrorData = res;
    });
  }

  public processMateoQueue(): Observable<any> {
      try {
          this.WriteDebugLog(
        'PollingService => processMateoQueue - Queue Count : ' +
          Polling.mateoQueue.size,
        new Map().set('QueueList', Polling.mateoQueue),
      );
      Polling.mateoQueue.forEach(queue => {
        try {
          if (queue.retryCount > this.numberOfTry) {
            this.angularZone.run(() => {
              this.ExecuteRetryExceeded(queue);
            });
          } else if (
            queue.pollingurl &&
            queue.pollingurl.length > 0 &&
            queue.HasToProcess
          ) {
            this.WriteDebugLog(
              'Mateo Queue Retry - ' + queue.retryCount,
              new Map().set('Queue Entry', queue),
            );
            queue.retryCount = queue.retryCount + 1;
            this.http
              .get<any>(queue.pollingurl, {
                observe: 'response',
                headers: new HttpHeaders().set(
                  'need-cache',
                  String(!!queue.needCache),
                ),
              })
              .pipe(
                map(response => {
                  if (response.status === 200) {
                    this.angularZone.run(() => {
                      this.ExecutePollingResponse200(queue, response);
                    });
                  } else if (response.status === 202) {
                    this.angularZone.run(() => {
                      this.ExecutePollingResponse202(queue, response);
                    });
                    /* This condition will hold response body of last request to get data from polling service
                                         when retry count exceeds 60 count then we will reuse last response data to get TCO details */
                    if (queue.retryCount === this.numberOfTry) {
                      this.retryExceededResponse = response.body;
                    }
                  }
                }),
                catchError(error => {
                  this.angularZone.run(() => {
                    this.ExecutePollingCallError(queue, error);
                  });
                  return error;
                }),
              )
              .subscribe(response => {});
          } else {
            this.WriteDebugLog(
              'Attempted retry before polling url was set.',
              new Map().set('Queue Entry', queue),
            );
          }
        } catch (err) {
          this.angularZone.run(() => {
            this.ExecutePollingProcessError(queue, err);
          });
          // this.handleError(err);
        }
      });
    } catch (ex) {
      this.WriteErrorLog(
        'Exception in PollingService => processMateoQueue',
        ex,
        new Map().set('QueueList', Polling.mateoQueue),
      );
    }
    return this.dummyMonitorObservable.asObservable();
  }

  private ExecuteRetryExceeded(queueItem: MateoQueue<any>) {
    queueItem.status = MateoQueueStatus.FAILED;
    Polling.RemoveQueue(queueItem.apiurl);
    this.errorService.executeGenericErrorCallback(
      queueItem,
      this.retryExceededResponse,
      this.tcoErrorData.RETRYERROR,
      this.tcoErrorData.TCOERROR,
    );

    if (queueItem.groupSubject) {
      queueItem.groupSubject.error(this.tcoErrorData.RETRYERROR);
    }
  }

  private ExecutePollingResponse200(
    queueItem: MateoQueue<any>,
    response: HttpResponse<any>,
  ) {
    if (queueItem.requestType === MateoQueueType.PATCH) {
      queueItem.processStatusFnRef(queueItem, response.body);
      if (queueItem.HasFailed) {
        this.ExecutePollingCallError(queueItem, response.body);
      } else {
        this.ExecutePollingCallSuccess(queueItem, response);
      }

      if (queueItem.groupSubject) {
        queueItem.groupSubject.complete();
      }
    } else {
      this.ExecutePollingCallSuccess(queueItem, response);
    }
  }

  private ExecutePollingCallSuccess(
    queueItem: MateoQueue<any>,
    response: HttpResponse<any>,
  ): void {
    queueItem.status = MateoQueueStatus.SUCCESS;
    this.WriteDebugLog(
      'Mateo Queue Completed',
      new Map().set('Queue Entry', queueItem),
    );
    if (queueItem.requestType === MateoQueueType.PATCH) {
      response.body.queueItem = queueItem;
    }
    Polling.RemoveQueue(queueItem.apiurl);
    if (queueItem.callbackSubject) {
      queueItem.callbackSubject.next(response.body);
    }
    this.errorService.checkQueueSize(queueItem);
    if (queueItem.groupSubject) {
      queueItem.groupSubject.complete();
    }
  }

  private ExecutePollingResponse202(
    queueItem: MateoQueue<any>,
    response: HttpResponse<any>,
  ) {
    queueItem.processStatusFnRef(queueItem, response.body);
    if (queueItem.HasFailed) {
      Polling.RemoveQueue(queueItem.apiurl);
      this.errorService.executeGenericErrorCallback(
        queueItem,
        this.retryExceededResponse ? this.retryExceededResponse : response.body,
        this.tcoErrorData.MATEOAPINOTFOUND,
        this.tcoErrorData.TCOERROR,
      );

      if (queueItem.groupSubject) {
        queueItem.groupSubject.next(response.body);
      }
    } else if (queueItem.HasSucceded) {
      this.ExecutePollingCallSuccess(queueItem, response);
    }
  }

  private ExecutePollingCallError(queueItem: MateoQueue<any>, error: any) {
    queueItem.status = MateoQueueStatus.FAILED;
    Polling.RemoveQueue(queueItem.apiurl);
    this.errorService.executeGenericErrorCallback(
      queueItem,
      error,
      this.tcoErrorData.TCOERROR,
    );
  }

  private ExecutePollingProcessError(queueItem: MateoQueue<any>, error: any) {
    queueItem.status = MateoQueueStatus.FAILED;
    Polling.RemoveQueue(queueItem.apiurl);
    this.errorService.executeGenericErrorCallback(
      queueItem,
      error,
      this.tcoErrorData.TCOERROR,
    );
    if (error.errors instanceof Array && queueItem.groupSubject) {
      queueItem.groupSubject.error(error.errors[0].detail);
    }
  }

  public StartMateoQueueMonitor() {
    this.angularZone.runOutsideAngular(() => {
      try {
        interval(5000)
          .pipe(
            startWith(0),
            switchMap(() => this.processMateoQueue()),
          )
          .subscribe(res => {
            this.WriteInfoLog(
              'PollingService => StartMateoQueueMonitor Completed.',
            );
          });
      } catch (ex) {
        this.WriteErrorLog(
          'Error in PollingService => StartMateoQueueMonitor ',
          ex,
        );
      }
    });
  }
}
