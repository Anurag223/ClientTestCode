
import {tap,  catchError } from 'rxjs/operators';
/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */
import { throwError, Observable, of } from 'rxjs';
import { AppError } from 'src/app/base/error/app-error';
import { NotFoundError } from 'src/app/base/error/not-found-error';
import { BadInput } from 'src/app/base/error/bad-input';
import {
  HttpClient,
  HttpInterceptor,
  HttpRequest,
  HttpHandler,
  HttpEvent,
  HttpResponse,
  HttpErrorResponse,
  HttpHeaders,
} from '@angular/common/http';

import * as _ from 'lodash';
import { Polling } from 'src/app/base/models/polling';
import { MateoQueueStatus } from 'src/app/base/models/mateoQueue';
import { LoggerService } from 'src/app/base/service/logger.service';
import { ApplicationException } from '../error/exception';
import { FMPHelper } from '../../../Constants/helpers';
import { AuthStorageKeys } from '../helpers/AuthenticationHelper';
import { AuditLogService } from 'src/app/modules/tlm-utils/auditlogging/auditlogging.service';

export abstract class DataService {
  constructor(
    public serviceName: string,
    public url: string,
    protected http: HttpClient,
    public _loggerService: LoggerService,
    public _auditService?:AuditLogService
  ) {}

  options = {
    headers: new HttpHeaders({
      'Content-Type': 'application/json',
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      Pragma: 'no-cache',
      Expires: '0'
    }),
    };
   simpleOptions = {
        headers: new HttpHeaders({
        }),
    };
    jsonOptions = {
        headers: new HttpHeaders({
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache',
        }),
    };

  // Takes a Map of key value pairs and converts them to a query sting.
  createQueryString(parameters: Map<string, string>): string {
    let queryString = '';

    if (parameters.size > 0) {
      // Iterate over all entries of parameters list.
      for (const key of Array.from(parameters.keys())) {
        // Validate if value exists.
        if (parameters.get(key)) {
          // Keep encoding and appending to query string for all key and value pairs.
          queryString += `${encodeURIComponent(key)}=${encodeURIComponent(
            parameters.get(key),
          )}&`;
        }
      }
    }

    // If parameters were appended remove the last &
    if (queryString && queryString.length > 0) {
      queryString = queryString.substr(0, queryString.length - 1);
    }

    return queryString;
  }

  selectall<T>(customurl?: string): Observable<T> {
    let selectallurl = customurl && customurl.length > 0 ? customurl : this.url;
    selectallurl = this.CheckForMockDataOverride(selectallurl);
    return this.http
      .get<T>(selectallurl, this.options)
      .pipe(catchError(this.handleError));
  }

  select<T>(id: string | number, customurl?: string): Observable<T> {
      let selecturl =
          customurl && customurl.length > 0 ? customurl : `${this.url}/${id}`;
      selecturl = this.CheckForMockDataOverride(selecturl);

      // only do this for internal endpoints(need to refine this mateo/fmp endpoints
      if (selecturl.toLowerCase().indexOf(FMPHelper.ApplicationSettings.influxDBBaseUrl) > -1) {
          this.options = this.simpleOptions;
      }

    return this.http
      .get<T>(selecturl, this.options)
      .pipe(catchError(this.handleError));
    }

  createForJson<T>(resource, customurl?: string): Observable<T> {
        const createurl = customurl && customurl.length > 0 ? customurl : this.url;
        return this.http
            .post<T>(createurl, resource, this.jsonOptions)
            .pipe(catchError(this.handleError));
  }
  create<T>(resource, customurl?: string): Observable<T> {
    const createurl = customurl && customurl.length > 0 ? customurl : this.url;
    return this.http
      .post<T>(createurl, resource, this.options)
      .pipe(catchError(this.handleError));
  }
  //createWithOptions<T>(resource: string, customOptions: any, customurl?: string): Observable<T> {
  //      const createurl = customurl && customurl.length > 0 ? customurl : this.url;
  //      return this.http
  //          .post<T>(createurl, resource, customOptions)
  //          .pipe(catchError(this.handleError));
  //}

  update<T>(resource, customurl?: string): Observable<T> {
    const updateurl = customurl && customurl.length > 0 ? customurl : this.url;
    return this.http
      .put<T>(updateurl, resource, this.options)
      .pipe(catchError(this.handleError));
  }

  updatepatch<T>(resource, customurl?: string): Observable<T> {
    const updateurl = customurl && customurl.length > 0 ? customurl : this.url;
    return this.http
      .patch<T>(updateurl, resource, this.options)
      .pipe(catchError(this.handleError));
  }

  delete<T>(id: string | number, customurl?: string): Observable<T> {
    const deleteurl =
      customurl && customurl.length > 0 ? customurl : `${this.url}/${id}`;
    return this.http
      .delete<T>(deleteurl, this.options)
      .pipe(catchError(this.handleError));
  }

  public handleError(err: Response) {
    if (err) {
      // this.WriteErrorLog('Error while using base service call.', err);
      if (err.status === 404) {
        return throwError(new NotFoundError(err));
      } else if (err.status === 400) {
        return throwError(new BadInput(err.json()));
      } else {
        return throwError(new AppError(err));
      }
    }
  }

  WriteDebugLog(message: string, parameters?: Map<string, any>) {
    this._loggerService.WriteDebug(this.serviceName, message, parameters);
  }

  WriteInfoLog(message: string, parameters?: Map<string, any>) {
    this._loggerService.WriteInfo(this.serviceName, message, parameters);
  }

  WriteErrorLog(
    message: string,
    exception: any,
    parameters?: Map<string, any>,
  ) {
    this._loggerService.WriteError(
      this.serviceName,
      message,
      exception,
      parameters,
    );
  }

  WriteWarningLog(message: string, parameters?: Map<string, any>) {
    this._loggerService.WriteWarning(this.serviceName, message, parameters);
  }


  WriteAuditLog(activityType:any, applicationName: any, oldValue: any, newValue: any){
    this._auditService.writeAuditLog(activityType, applicationName, oldValue, newValue).
    subscribe((data) => {
      console.log(data);
     });
  }

  public CheckForMockDataOverride<T>(apiurl: string): string {
    let returnValue = apiurl;
    if (FMPHelper.ApplicationSettings.UseMockData) {
      FMPHelper.ApplicationSettings.MockDataUrlMap.forEach((val, key) => {
        if (FMPHelper.StringContains(apiurl, key)) {
          returnValue = val;
        }
      });
    }
    return returnValue;
  }
}

export class MateoApiInterceptor implements HttpInterceptor {
  private cache: Map<String, HttpResponse<any>> = new Map();

  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<any> {
    
      const cacheKey = request.url;


    let cachedResponse: HttpResponse<any> = null;
    if (
      request.method.match(/get/i) &&
      request.headers.get('need-cache') === 'true'
    ) {
      cachedResponse = this.cache.get(cacheKey);
    }
    request = this.AddRequiredReqeustHeaders(request);
    const eventSource: Observable<any> = cachedResponse
      ? of(cachedResponse)
      : next.handle(request);
    return eventSource.pipe(tap(
      function(key: String, needsToCache: boolean, event: HttpEvent<any>) {
        if (event instanceof HttpResponse) {
          if (
            event.status === 200 &&
            needsToCache &&
            request.method.match(/get/i) &&
            request.url.match(/cmmssites|equipmentrequests/)
          ) {
            this.cache.set(key, event);
            setTimeout(
              function(k: String) {
                this.cache.delete(k);
              }.bind(this, key),
              60 * 60 * 1000,
            );
          } else if (
            event.status === 202 &&
            Polling.mateoQueue.has(request.url)
          ) {
            const location = event.headers.get('Location');

            const queue = Polling.mateoQueue.get(request.url);
            // Update the Queue with Polling url
            if (location && location.length > 0) {
              queue.pollingurl =
                FMPHelper.ApplicationSettings.baseSettings.mateoBaseUrl +
                location;
              queue.status = MateoQueueStatus.POLLING;
            } else {
              queue.status = MateoQueueStatus.FAILED;
              Polling.RemoveQueue(request.url);
            }
          }
        }
      }.bind(this, cacheKey, !cachedResponse),
      (err: any) => {
        if (err instanceof HttpErrorResponse) {
          if (err.status === 401) {
            // redirect to the login route
            // this.router.navigate([FMPHelper.Routes.UnAuthorized.path]);
            if (Polling.unAuthorizedObservable) {
              Polling.unAuthorizedObservable.next(true);
            }
          }

          const queueitem = Polling.GetQueue(err.url);
          if (queueitem) {
            queueitem.status = MateoQueueStatus.FAILED;
            Polling.RemoveQueue(queueitem.apiurl);
            if (queueitem.errorCallbackSubject) {
              const ex: ApplicationException = new ApplicationException(
                'MateoApiInterceptor',
                'Exception in Mateo Interceptor',
                err,
              );
              ex.parameters.set('Mateo Queue', queueitem);
              queueitem.errorCallbackSubject.next(ex);
              queueitem.errorCallbackSubject = null;
            }
          }
        }
      },
    ));
  }

  private AddRequiredReqeustHeaders(request: HttpRequest<any>,): HttpRequest<any> {
      const token: string = FMPHelper.ReadFromLocalStorage(
      AuthStorageKeys.FMP_AUTH_AUTHORIZATIONDATA,
    );
    const bearerToken =
      token && !FMPHelper.StringIsNullOrWhiteSpace(token)
        ? `Bearer ${token}`
        : '';
      // only do this for internal endpoints(need to refine this mateo/fmp endpoints
      if (request.url.toLowerCase().indexOf(FMPHelper.ApplicationSettings.influxDBBaseUrl) > -1
      //    || request.url.toLowerCase().indexOf(FMPHelper.ApplicationSettings.standardWorkBaseUrl) > -1
      //    || request.url.toLowerCase().indexOf('/equipment-doms.endpoints') > -1
      ) {
          let username = '';
          let pass = '';// move out to API

          return request.clone(
              {
                   
                  setHeaders:
                  {
                      'Accept': 'application/json',
                      'Authorization': 'Basic ' + btoa(username + ':' + pass)
                  }
              });
      }

      // if (request.url.toLowerCase().indexOf(FMPHelper.ApplicationSettings.ehcAPI) > -1) {
      //     return request.clone(
      //         {
      //             setHeaders:
      //             {
      //                 'Accept': 'application/json',
      //                 //Authorization: bearerToken,
      //                'x-apikey': 'some key here' // to be removed
      //             }
      //         });
      // }
      if (request.url.toLowerCase().indexOf('odm_phwf') > -1) {
          return request.clone(
              {
                  setHeaders:
                  {
                      'Accept': 'application/json',
                      //Authorization: bearerToken,
                      'x-apikey': 'some key here'
                  }
              });
      }
      if (request.url.toLowerCase().indexOf('/equipment-doms.endpoints') > -1) {
          return request.clone(
              {
                  setHeaders:
                  {
                      'Accept': 'application/json',
                      'Authorization': 'Bearer some token here',
                      'AppKey': 'somekeyhere',
                      'slb-data-partition-id': 'slb'
                  }
              });
      }
      if (request.url.toLowerCase().indexOf('/ehc-agent-status') > -1) {
          return request.clone(
              {
                  setHeaders:
                  {
                      'Accept': 'application/json',
                      'token': 'sometoken here',
                  }
              });
      } 

      if (bearerToken && bearerToken.length > 0)
      {
          return request.clone(
             {
                setHeaders:
                {
                     Authorization: bearerToken,
                     'Accept': 'application/json',
                },
                headers: new HttpHeaders({
                  'Cache-Control': 'no-cache, no-store, must-revalidate',
                  Pragma: 'no-cache',
                  Expires: '0',
                }),
            });
      }
      else {
      return request;
    }
  }
}
