/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */
import { Injectable } from '@angular/core';
import { LogLevel } from 'src/Constants/application';
import { FMPHelper } from 'src/Constants/helpers';

@Injectable({
  providedIn: 'root'
})
export class LoggerService {

  public CurrentLogLevel: LogLevel;

  //#region Logging Check Flags
  private get IsDebugEnabled(): boolean {
    return this.CurrentLogLevel === LogLevel.Debug;
  }

  private get IsInfoEnabled(): boolean {
    return this.CurrentLogLevel !== LogLevel.None && (this.CurrentLogLevel === LogLevel.Debug
      || this.CurrentLogLevel === LogLevel.Information);
  }

  private get IsWarningEnabled(): boolean {
    return this.CurrentLogLevel !== LogLevel.None && (this.CurrentLogLevel === LogLevel.Debug
      || this.CurrentLogLevel === LogLevel.Information
      || this.CurrentLogLevel === LogLevel.Warning);
  }

  private get IsErrorEnabled(): boolean {
    return this.CurrentLogLevel !== LogLevel.None;
  }

  private get IsConsoleOnly(): boolean {
    return this.CurrentLogLevel !== LogLevel.None && this.CurrentLogLevel === LogLevel.ConsoleOnly;
  }
  //#endregion

  constructor() {
    this.CurrentLogLevel = FMPHelper.ApplicationSettings.baseSettings.logLevel;
  }

  //#region Write Log Methods
  WriteDebug(name: string, message: string, parameters?: Map<string, any>) {
    if (this.IsConsoleOnly) {
      console.log(`${name} => ${message}`);
    } else if (this.IsDebugEnabled) {
      const log = new DebugLog(name);
      log.message = message;
      log.parameters = parameters;
      this.WriteDebugLog(log);
    }
  }

  WriteInfo(name: string, message: string, parameters?: Map<string, any>) {
    if (this.IsConsoleOnly) {
      console.log(`${name} => ${message}`);
    } else if (this.IsInfoEnabled) {
      const log = new InfoLog(name);
      log.message = message;
      log.parameters = parameters;
      this.WriteInfoLog(log);
    }
  }

  WriteError(name: string, message: string, exception: any, parameters?: Map<string, any>) {
    if (this.IsConsoleOnly) {
      if (console.error) {
        console.error(`${name} => ${message}`);
      } else if (console.exception) {
        console.exception(`${name} => ${message}`);
      } else {
        console.log(`${name} => ${message}`);
      }
      this.WriteDataLog(exception)
    } else if (this.IsErrorEnabled) {
      const log = new ErrorLog(name, exception);
      log.message = message;
      log.parameters = parameters;
      this.WriteErrorLog(log);
    }
  }

  WriteWarning(name: string, message: string, parameters?: Map<string, any>) {
    if (this.IsConsoleOnly) {
      if (console.warn) {
        console.warn(`${name} => ${message}`);
      } else {
        console.log(`${name} => ${message}`);
      }
    } else if (this.IsWarningEnabled) {
      const log = new WarningLog(name);
      log.message = message;
      log.parameters = parameters;
      this.WriteWarningLog(log);
    }
  }

  WriteDataLog(data: any) {
    if (this.CurrentLogLevel !== LogLevel.None) {
      if (data) {
        if (console.table) {
          console.table({ Output: data });
        } else {
          console.log(data);
        }
      }
    }
  }
  //#endregion

  //#region Logging Methods
  private WriteDebugLog(log: DebugLog) {
    log.TimeStamp = new Date();
    log.logType = LogType.Debug;
    console.log(log);
  }

  private WriteInfoLog(log: InfoLog) {
    log.TimeStamp = new Date();
    log.logType = LogType.Info;
    console.log(log);
  }

  private WriteWarningLog(log: WarningLog) {
    log.TimeStamp = new Date();
    log.logType = LogType.Warning;
    if (console.warn) {
      console.warn(log);
    } else {
      console.log(log);
    }
    this.WriteDataLog(log.parameters);
  }

  private WriteErrorLog(log: ErrorLog) {
    log.TimeStamp = new Date();
    log.logType = LogType.Error;
    if (console.error) {
      console.error(log);
    } else if (console.exception) {
      console.exception('Error', log);
    } else {
      console.log(log);
    }
    this.WriteDataLog(log.parameters);
  }
  //#endregion

  SetLogLevel(_logLevel: LogLevel) {
    this.CurrentLogLevel = _logLevel;
  }
}

class BaseLog {
  referenceName: string;
  parameters: Map<string, any>;
  message: string;
  TimeStamp: Date;
  logType: LogType;
}

export class DebugLog extends BaseLog {
  constructor(_referenceName: string) {
    super();
    this.referenceName = _referenceName;
    this.logType = LogType.Debug;
  }
}

export class InfoLog extends BaseLog {
  constructor(_referenceName: string) {
    super();
    this.referenceName = _referenceName;
    this.logType = LogType.Info;
  }
}

export class ErrorLog extends BaseLog {
  constructor(_referenceName: string, _exception: any) {
    super();
    this.referenceName = _referenceName;
    this.exception = _exception;
    this.logType = LogType.Error;
  }
  exception: any;
}

export class WarningLog extends BaseLog {
  constructor(_referenceName: string) {
    super();
    this.referenceName = _referenceName;
    this.logType = LogType.Warning;
  }
}

export enum LogType {
  Debug = 'Debug',
  Info = 'Information',
  Warning = 'Warning',
  Error = 'Error'
}
