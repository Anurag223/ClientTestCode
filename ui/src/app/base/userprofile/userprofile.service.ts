
import {map,  catchError, tap } from 'rxjs/operators';
/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse } from '@angular/common/http';
import { Observable ,  Subject } from 'rxjs';



import {
  IUserProfile,
  UserRoleSiteDataModel,
  UserProfileDataModel,
  UserProfile,
  IUserPreference,
  Role,
  SavedPreference,
  UserPreference,
  UserProfileRequestModel,
} from '../models/userprofile';
import { ApplicationException } from '../error/exception';
import { FMPHelper } from '../../../Constants/helpers';
import { PatchJson } from '../../base/models/patchjson';
import { DataService } from '../service/data.service';
import { MateoApiServiceHandle } from '../service/mateo-api-service-handle.service';
import { LoggerService } from '../service/logger.service';
import { MateoQueue, MateoQueueStatus} from '../models/mateoQueue';

/**
 * User Profile Service Fetches the User Profiles from CMMS System (Mateo) and User Preferences FMP (Mongo DB)
 * Also User Profile service saves the user preferences in mongo db.
 * @export
 * @class UserprofileService
 * @extends {DataService}
 */
@Injectable()
export class UserprofileService extends DataService {
  public userRoleObservable = new Subject<Role>();
  public userProfileApiObservable = new Subject<UserProfile>();
  public userProfileErrorObservable = new Subject<ApplicationException>();
  public userRoleSiteProfile: UserRoleSiteDataModel;
  public dataModel: UserProfileDataModel;
  public userPreferencesObservable = new Subject<SavedPreference>();

  cacheOn = false;

  /**
   *Creates an instance of UserprofileService.
   * @param {HttpClient} _http
   * @param {MateoApiServiceHandle} mateoHandle
   * @param {LoggerService} _loggerService
   * @memberof UserprofileService
   */
  constructor(
    private _http: HttpClient,
    private mateoHandle: MateoApiServiceHandle,
    public _loggerService: LoggerService,
  ) {
    super('UserprofileService', '', _http, _loggerService);
    this.userRoleSiteProfile = new UserRoleSiteDataModel();
    this.dataModel = new UserProfileDataModel();
  }

  /**
   * This Function makes calls to the user api
   *
   * @param {UserProfileRequestModel} requestModel
   * @returns {UserProfileRequestModel}
   * @memberof UserprofileService
   */
  getUserProfileFromMateo(
    requestModel: UserProfileRequestModel,
  ): UserProfileRequestModel {
    const url =
      FMPHelper.ApplicationSettings.mateoUserAPI +
      encodeURIComponent(requestModel.userldap) +
      '/profile'; // ?productLine=' + encodeURIComponent(requestModel.productLine);

    const mateoQueue: MateoQueue<UserProfile> = new MateoQueue<UserProfile>(
      url,
    );
    mateoQueue.callbackSubject = this.userProfileApiObservable;
    mateoQueue.errorCallbackSubject = this.userProfileErrorObservable;
    mateoQueue.processStatusFnRef = this.HandelUserProfilePollingStatus;
    this.mateoHandle.HandleMateoGet(mateoQueue);
    requestModel.QueueItem = mateoQueue;
    return requestModel;
  }

  /**
   * Event that manages the cross component communication for UserProfile and other components
   *
   * @param {Role} _role
   * @memberof UserprofileService
   */
  triggerSiteUpdate(_role: Role) {
    this.userRoleObservable.next(_role);
  }

  /**
   * This function gets the last visited application name from mongo db
   *
   * @param {string} ldap
   * @returns {Observable<string>}
   * @memberof UserprofileService
   */
  getLastApplicationName(ldap: string): Observable<string> {
    const url = `${FMPHelper.ApplicationSettings.userProfileAPI +
      'GetLastApplicationName'}/?Ldap=${ldap}`;
    return this._http
      .get<string>(url).pipe(
      map(res => (res === null ? '' : res.toString())))
      .pipe(catchError(this.handleError));
  }

  /**
   * This function saves the last application user has visited to.
   *
   * @param {string} ldap
   * @param {string} appName
   * @returns {Observable<any>}
   * @memberof UserprofileService
   */
  saveLastApplicationName(ldap: string, appName: string): Observable<any> {
    const options = {
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Cache-Control': 'no-cache',
      }),
    };
    const body = {
      Ldap: ldap,
      ApplicationName: appName,
    };

    const url =
      FMPHelper.ApplicationSettings.userProfileAPI + 'SaveLastApplicationName';
    return this._http
      .post<any>(url, body, options)
      .pipe(catchError(this.handleError));
  }

  /**
   * This function saves the selected role and site
   *
   * @param {UserProfile} userprofile
   * @returns {Observable<UserRoleSiteDataModel>}
   * @memberof UserprofileService
   */
  saveUserRoleSiteMapping(
    userprofile: UserProfile,
  ): Observable<UserRoleSiteDataModel> {
    if (userprofile) {
      this.userRoleSiteProfile.userID = userprofile.ldapAlias;
        this.userRoleSiteProfile.roleName = userprofile.seletedRole.fmpRoleName;
      this.userRoleSiteProfile.activeLocations = userprofile.seletedRole.seletedWorkLocations
        .map(site => site.workLocation)
        .join(',');
    }

    const options = {
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Cache-Control': 'no-cache',
      }),
      };
      
    return this._http.post<UserRoleSiteDataModel>(
      FMPHelper.ApplicationSettings.userProfileAPI + 'SaveUserRoleLocation',
      this.userRoleSiteProfile,
      options,
    );
  }

  /**
   * This function gets the profile preferences for the user
   *
   * @param {string} ldap
   * @returns {Observable<IUserPreference[]>}
   * @memberof UserprofileService
   */
  getUserProfilePreferences(ldap: string): Observable<IUserPreference[]> {
    const url = `${
      FMPHelper.ApplicationSettings.userProfileAPI
    }GetUserRoleLocation/?Ldap=${ldap}`;
    return this.selectall<IUserPreference[]>(url);
  }

  /**
   * This function saves the refresh interval for the AM grid.
   *
   * @param {string} ldap
   * @param {string} appName
   * @param {number} interval
   * @returns {Observable<any>}
   * @memberof UserprofileService
   */
  saveRefreshIntervalInformation(
    ldap: string,
    appName: string,
    interval: number,
  ): Observable<any> {
    const options = {
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Cache-Control': 'no-cache',
      }),
    };
    const body = {
      Ldap: ldap,
      ApplicationName: appName,
      RefreshInterval: interval,
    };

    const url =
      FMPHelper.ApplicationSettings.userProfileAPI +
      'saveRefreshIntervalInformation';
    return this._http
      .post<any>(url, body, options)
      .pipe(catchError(this.handleError));
  }

  /**
   * This function updates the user preferences
   *
   * @param {UserPreference} userPreference
   * @returns {Observable<boolean>}
   * @memberof UserprofileService
   */
  UpdateUserPreferences(userPreference: UserPreference): Observable<boolean> {
    const url =
      FMPHelper.ApplicationSettings.userProfileAPI + 'SaveUserPreference';
    return this.update(userPreference, url);
  }

  /**
   * This function hanldes the polling status for user api.
   *
   * @param {MateoQueue<any>} queue
   * @param {*} body
   * @memberof UserprofileService
   */
  HandelUserProfilePollingStatus(queue: MateoQueue<any>, body: any) {
    if (body && body.userStatus) {
      if (body.userStatus === 3 || body.userStatus === 4) {
        queue.status = MateoQueueStatus.FAILED;
      }
    }
  }

  /**
   * Sets the front end cache for requests on and off
   * @param boolean cacheOn
   */
  setCacheOn(cacheOn: boolean) {
    this.cacheOn = cacheOn;
  }

  /**
   * Return true if front-end caching is turned on for requests, false otherwise
   *
   * @returns boolean
   */
  isCacheOn(): boolean {
    return this.cacheOn;
  }
  /**
   * This function gets release note from mongo db
   *
   * @returns {Observable<any>}
   * @memberof UserprofileService
   */
  getReleaseNote(): Observable<any> {
    const url = `${FMPHelper.ApplicationSettings.releaseNoteUrl}`;
    return this._http.get<any>(url).pipe(catchError(this.handleError));
  }
  /**
   * This function updates the user preferences
   *
   * @param {UserPreference} userPreference
   * @returns {Observable<boolean>}
   * @memberof UserprofileService
   */
  UpdateReleaseNoteSetting(
    Ldap: string,
    patch: PatchJson,
  ): Observable<boolean> {
    const url = `${
      FMPHelper.ApplicationSettings.userProfileAPI
    }UpdateReleaseNoteSetting/${Ldap}`;
    return this.updatepatch(patch, url);
  }
}
