/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */
import {
  GridComponent,
  ColumnComponent,
  DataStateChangeEvent,
  SelectableSettings,
} from '@progress/kendo-angular-grid';
import {
  GroupDescriptor,
  FilterDescriptor,
  SortDescriptor,
  CompositeFilterDescriptor,
  DataResult,
} from '@progress/kendo-data-query';
import { FMPHelper } from 'src/Constants/helpers';

export class GridPagerConfigModel {
  buttonCount: number;
  pageSizeOptions: number[];
}

export class GridConfigModel {
  take: number;
  skip: number;
  defaultPageSize: number;
  isPagingEnabled: boolean;
  isSortingEnabled: boolean;
  isFilteringEnabled: boolean;
  isGroupingEnabled: boolean;
  isColumnReOrderEnabled: boolean;
  isColumnResizingEnabled: boolean;
  gridHeight: number;
  sorting: any;

  pager: GridPagerConfigModel;
  public expandCounter: number;
  public collapseCounter: number;
  public isCollapsed: boolean;
  public isExpanded: boolean;
  public isCollapsedLevel: boolean;
  public isExpandedLevel: boolean;

  public DataGridResult: DataResult;
  public DataGridInstance: GridComponent;
  public columns: ColumnComponent[];
  public GroupSettings: GroupDescriptor[];
  public SortSettings: SortDescriptor[] = [];
  public FilterSettings: CompositeFilterDescriptor;
  public selectableSettings: SelectableSettings;
  public GridDateFields: string[];

  /**
   * This method is used to set the State object for grid
   * It sets the Group, Filter, Sorting and pagination properties
   * @readonly
   * @type {DataStateChangeEvent}
   * @memberof GridConfigModel
   */
  get GridState(): DataStateChangeEvent {
    const gridstate: DataStateChangeEvent = {
      take: !(this.take && this.take > 0) ? 20 : this.take,
      skip: this.skip ? this.skip : 0,
      filter: this.parseGridFilters(this.FilterSettings),
      sort: this.SortSettings
        ? FMPHelper.CloneJSONObject(this.SortSettings)
        : [],
      group: this.GroupSettings
        ? FMPHelper.CloneJSONObject(this.GroupSettings)
        : [],
    };
    return gridstate;
  }

  private parseGridFilters(
    filterInstance: CompositeFilterDescriptor,
  ): CompositeFilterDescriptor {
    let filterInstanceCopy: CompositeFilterDescriptor = {
      filters: [],
      logic: 'and',
    };
    if (filterInstance) {
      filterInstanceCopy = FMPHelper.CloneJSONObject(
        filterInstance,
      ) as CompositeFilterDescriptor;
      filterInstanceCopy.filters.forEach(filter => {
        const compFilter = filter as CompositeFilterDescriptor;
        const simpleFilter = filter as FilterDescriptor;
        if (compFilter && compFilter.filters && compFilter.filters.length > 0) {
          this.parseGridFilters(compFilter);
        } else if (simpleFilter) {
          if (
            simpleFilter.value &&
            this.GridDateFields.some(fld =>
              FMPHelper.StringEqual(fld, simpleFilter.field as string),
            )
          ) {
            simpleFilter.value = new Date(simpleFilter.value);
          }
        }
      });
    }
    return filterInstanceCopy;
  }
}
export class GridColumn {
  DataName: string;
  Width: number;
  ExcelVisible: boolean;
  IsEditable: boolean;

  constructor(
    dataName: string,
    width: number,
    excelvisible: boolean = true,
    isEditable: boolean = false,
  ) {
    this.DataName = dataName;
    this.Width = width;
    this.ExcelVisible = excelvisible;
    this.IsEditable = isEditable;
  }
}

const flatten = group =>
  group.items.reduce((acc, x) => {
    return [...acc, ...(x.items ? flatten(x) : x)];
  }, []);

export interface IGridRequiredProperties<T> {
  isChecked: boolean;
  UniqueID: T;
}

export class GridGroupContext {
  /**
   *Create group context which cotains group and flatterened list of items in the group.
   */
  constructor(group: any) {
    if (group) {
      this.GroupData = group;
      this.GroupPageItems = flatten(group);
    }
    this.GroupAllItems = this.GroupPageItems ? this.GroupPageItems : [];
  }

  GroupDetails: GroupDescriptor;
  GroupHierarchy: GroupDescriptor[];
  GroupData: any;
  GroupPageItems: any[];
  GroupAllItems: any[];
}
