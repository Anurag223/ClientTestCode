
import {distinctUntilChanged, debounceTime} from 'rxjs/operators';
/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */
//#region namespace
import {
  Component,
  OnInit,
  Input,
  ViewChild,
  OnDestroy,
  ChangeDetectorRef,
} from '@angular/core';
import { ColumnOptionsService } from '../../../sharedcomponents/columnOptions/columnoptions.service';

import { FMPConstant } from '../../../../Constants/constant';

import { FMPHelper } from '../../../../Constants/helpers';
import { IUserProfileLayout } from '../../../sharedcomponents/models/columnoptions';
import {
  SideNavViewModel,
  IActiveLayout,
  LayoutColumn,
  Layout,
  LayoutTypes,
} from '../../../sharedcomponents/models/sidenav-overlay';
import * as $ from 'jquery';
import * as LO from 'lodash';
import {
  GridConfigModel,
  GridPagerConfigModel,
} from '../../../sharedcomponents/models/sharedmodels';
import { ColumnComponent } from '@progress/kendo-angular-grid';
import { throwError, Subject ,  Subscription } from 'rxjs';
import { AppError } from '../../../base/error/app-error';
import { DropDownListComponent } from '@progress/kendo-angular-dropdowns';
import { AppToasterService } from '../../../base/toaster/toaster.service';
import {
  GroupDescriptor,
  FilterDescriptor,
  SortDescriptor,
  CompositeFilterDescriptor,
} from '@progress/kendo-data-query';
import { BaseComponent } from '../../../base/component/base/base.component';
import { LoggerService } from '../../../base/service/logger.service';
import { ApplicationException } from '../../../base/error/exception';




@Component({
  selector: 'app-shared-columnoptions',
  templateUrl: './columnoptions.component.html',
  styleUrls: ['./columnoptions.component.scss'],
})
export class ColumnOptionsComponent extends BaseComponent
  implements OnInit, OnDestroy {
  @Input() viewModel: SideNavViewModel;
  @Input() gridModel: GridConfigModel;
  @Input() defaultColumns: string[];

    @ViewChild('layoutDropdown', { static: false }) layoutDropDown: DropDownListComponent;

  layoutNameChangedSubject: Subject<string> = new Subject<string>();
  layoutNameChangedSubscription: Subscription;
  layoutSubscription: Subscription;
  /**
   * Check filterconfig filters with layout column filters,
   * if any filter doesn't match then it removes the unmatch filter from filterconfig object.
   */
  private removeFilter = (
    layoutColumns: ColumnComponent[],
    filterConfig: any,
  ) => {
    this.WriteDebugLog('ColumnOptionsComponent => removeFilter');
    const currentFilters = filterConfig;
    for (let k = currentFilters.filters.length - 1; k >= 0; --k) {
      const filterWithNoColumn = layoutColumns.filter(
        b => b.field === currentFilters.filters[k].filters[0].field,
      );
      if (filterWithNoColumn.length === 0) {
        currentFilters.filters.splice(k, 1);
      }
    }
  };

  /**
   * Creates an instance of ColumnOptionsComponent.
   */
  constructor(
    private columnOptionService: ColumnOptionsService,
    private toasterService: AppToasterService,
    loggerService: LoggerService,
    private changeDetector: ChangeDetectorRef,
  ) {
    super('ColumnOptionsComponent', loggerService);
    this.WriteDebugLog('ColumnOptionsComponent => constructor');
  }

  //#region ngOnInit
  ngOnInit() {
    this.WriteDebugLog('ColumnOptionsComponent => ngOnInit');
    try {
      this.layoutSubscription = this.columnOptionService.layoutChangeObservable.subscribe(
        lay => {
          this.WriteDebugLog(
            'ColumnOptionsComponent => layoutSubscription Trigger Hit.',
          );
          if (lay && this.viewModel.showColumnOptions) {
            this.WriteDebugLog(
              'ColumnOptionsComponent => layoutChangeSubscription triggered.',
            );
            this.viewModel.selectedLayout = lay;
            this.viewModel.columnOptionsBound = new Layout(lay);
            this.CalculateAllColumns();
            let seq = 0;
            this.viewModel.columnOptionsBound.layoutConfigs.forEach(col => {
              col.selectedColumn = col;
              col.sequence = seq++;
            });
            this.changeDetector.detectChanges();
          }
        },
        error => this.WriteDebugLog(error),
      );
      // Debouncing text change not to trigger the Change Detection on every
      this.layoutNameChangedSubscription = this.layoutNameChangedSubject.pipe(
        debounceTime(500), // wait 500ms after the last event before emitting last event
        distinctUntilChanged(),) // only emit if value is different from previous value
        .subscribe(layoutName => {
          this.viewModel.columnOptionsBound.layoutName = layoutName;
          this.changeDetector.detectChanges();
        });
    } catch (err) {
      this.WriteDebugLog(err);
    }
  }

  /**
   * This function trigger when user click on Cancel button / Cross icon.
   */
  closeColumnOptions() {
    this.WriteDebugLog('ColumnOptionsComponent => closeColumnOptions');
    document.getElementById('myColumnOptions').style.width = '0px';
    this.viewModel.columnOptionsBound = null;
    this.viewModel.showColumnOptions = false;
  }

  /**
   * This function executes when user change active layout / template from dropdown.
   */
  onLayoutChange(event: Layout) {
    this.WriteDebugLog('ColumnOptionsComponent => onLayoutChange');
    this.columnOptionService.triggerLayoutChange(event);
  }

  /**
   * Disable the items
   */
  public itemDisabled(itemArgs: { dataItem: Layout; index: number }) {
    return itemArgs && itemArgs.dataItem
      ? itemArgs.dataItem.isSeperator
      : false;
  }

  /**
   * This function triggers when user open the additional column list combo box.
   */
  onColumnsSelectionChange(event, item: LayoutColumn) {
    this.WriteDebugLog('ColumnOptionsComponent => onColumnsSelectionChange');
    const remainingColumns: LayoutColumn[] = this.CalculateRemainingColumns();
    item.DropDownSource =
      item.selectedColumn &&
      item.selectedColumn.fieldName &&
      item.selectedColumn.fieldName.length > 0
        ? [item.selectedColumn, ...remainingColumns]
        : remainingColumns;
  }

  /**
   * Sets the layout to be Public.
   */
  onPublicChecked(event: boolean) {
    if (
      FMPHelper.StringEqual(
        this.viewModel.columnOptionsBound.userID,
        this.viewModel.user.ldapAlias,
      )
    ) {
      this.viewModel.columnOptionsBound.layoutType = event
        ? LayoutTypes.Public
        : LayoutTypes.Private;
    }
  }

  /**
   * This function calculate and set all the additional columns (selected & non-selected) to the viewModel AllColumns property.
   */
  CalculateAllColumns() {
    this.WriteDebugLog('ColumnOptionsComponent => CalculateAllColumns');
    try {
      const remainingColumns: LayoutColumn[] = this.CalculateRemainingColumns();
      this.viewModel.AllColumns = [
        ...this.viewModel.selectedLayout.layoutConfigs,
        ...remainingColumns,
      ];
      this.viewModel.columnOptionsBound.layoutConfigs.forEach(col => {
        col.DropDownSource = [col, ...remainingColumns];
        col.selectedColumn = col;
      });
      this.SortBoundColumns();
    } catch (err) {
      this.WriteDebugLog(err);
    }
  }

  /**
   * Returns list of additional columns which are not selected in the active template.
   */
  CalculateRemainingColumns(): LayoutColumn[] {
    this.WriteDebugLog('ColumnOptionsComponent => CalculateRemainingColumns');
    const seletedCols = this.GetSelectedColumns();
    let colId: number = LO.maxBy<LayoutColumn>(seletedCols, c => c.columnId)
      .columnId;
    let remainingColumns: LayoutColumn[] = [];
    LO.filter<ColumnComponent>(
      this.gridModel.columns,
      gcol =>
        !LO.some<LayoutColumn>(
          seletedCols,
          lcol => lcol.fieldName === gcol.field,
        ),
    ).forEach(col => {
      const inst = new LayoutColumn(null);
      inst.columnId = colId++;
      inst.columnName = col.title;
      inst.fieldName = col.field;
      inst.sequence = -1;
      inst.selectedColumn = inst;
      inst.isDefault = LO.some<string>(
        this.defaultColumns,
        c => c === col.title,
      );
      if (inst.columnName && inst.columnName !== '') {
        remainingColumns.push(inst);
      }
    });
    remainingColumns = LO.sortBy<LayoutColumn>(remainingColumns, 'columnName');
    return remainingColumns;
  }

  /**
   * Returns the List of selected columns of active layout / template.
   */
  GetSelectedColumns(): LayoutColumn[] {
    this.WriteDebugLog('ColumnOptionsComponent => GetSelectedColumns');
    let seq = 1;
    let columns: LayoutColumn[] = this.viewModel.columnOptionsBound.layoutConfigs.map(
      l => (l.selectedColumn ? l.selectedColumn : l),
    );
    columns.forEach(c => {
      c.sequence = seq++;
      c.selectedColumn = c;
    });
    columns = LO.remove<LayoutColumn>(
      columns,
      col => !FMPHelper.StringIsNullOrWhiteSpace(col.fieldName),
    );
    columns.forEach(col => {
      const colInst = this.gridModel.columns.find(
        c => c.field === col.fieldName,
      );
      if (colInst) {
        col.fieldName = colInst.field;
        col.columnName = colInst.title;
        col.isLocked = col.isLocked ? col.isLocked : false;
      } else {
        const exp: ApplicationException = new ApplicationException(
          this.componentName,
          'Could not find grid column for layout column',
          null,
          new Map().set('Layout Column', col),
        );
        this.WriteErrorLog(exp.errorMessage, exp);
        col.columnName = 'Error...';
        col.fieldName = 'Error...';
      }
    });
    return columns;
  }

  /**
   * This function triggers when user click on "Add New" button.
   */
  onAddNewLayout(event) {
    if (
      this.viewModel.usersLayouts.length <
      FMPConstant.ColumnOptions.maxAllowedLayouts
    ) {
      this.WriteDebugLog('ColumnOptionsComponent => onAddNewLayout');
      const newLayout = new Layout(this.viewModel.selectedLayout);
      newLayout.layoutName = '';
      newLayout.layoutType = LayoutTypes.Private;
      newLayout.userID = this.viewModel.user.ldapAlias;
      newLayout.isNew = true;
      this.viewModel.columnOptionsBound = newLayout;
      this.CalculateAllColumns();
      this.changeDetector.detectChanges();
      setTimeout(() => {
        const columnControlEdit: any = $('#editNewlayout');
        columnControlEdit.focus();
      }, 500);
      this.onCDDetach();
    } else {
      this.toasterService.ShowError(
        FMPConstant.ColumnOptions.maxAllowedLayoutsMessage,
      );
    }
  }

  /**
   * This function trigger when user types name of the template.
   */
  onLayoutNameChanged(event: string): void {
    this.layoutNameChangedSubject.next(event);
  }

  /**
   * This function executes when user deletes any column from selected template.
   */
  onColumnDelete(event, item: LayoutColumn) {
    this.WriteDebugLog('ColumnOptionsComponent => onColumnDelete');
    LO.remove<LayoutColumn>(
      this.viewModel.columnOptionsBound.layoutConfigs,
      col => col.selectedColumn.fieldName === item.selectedColumn.fieldName,
    );
    this.gridModel.FilterSettings.filters = this.gridModel.FilterSettings.filters.filter(
      el => {
        (el as CompositeFilterDescriptor).filters = (el as CompositeFilterDescriptor).filters.filter(
          a => {
            return (a as FilterDescriptor).field !== item.fieldName;
          },
        );
        return true;
      },
    );
    this.gridModel.GroupSettings = this.gridModel.GroupSettings.filter(el => {
      return el.field !== item.fieldName;
    });

    this.gridModel.SortSettings = this.gridModel.SortSettings.filter(el => {
      return el.field !== item.fieldName;
    });
  }

  /**
   * This function executes when user lock/unlock any column of active template/layout.
   */
  onLockClick(event, column: LayoutColumn, index) {
    this.WriteDebugLog('ColumnOptionsComponent => onLockClick');
    column.isLocked = !column.isLocked;
    this.SortBoundColumns();

    const columns: LayoutColumn[] = this.GetSelectedColumns();
    const lockedColumns = LO.sortBy<LayoutColumn>(
      columns.filter(c => c.isLocked),
      col => col.sequence,
    );
    this.ReCalculateAllColumnSource();
  }

  /**
   * This method we are sorting/arranging sequence of columns of an template like
   * locked columns first then unlocked columns at the bottom/end of template.
   */
  SortBoundColumns() {
    this.WriteDebugLog('ColumnOptionsComponent => SortBoundColumns');
    const columns: LayoutColumn[] = this.GetSelectedColumns();
    const lockedColumns = LO.sortBy<LayoutColumn>(
      columns.filter(c => c.isLocked),
      col => col.sequence,
    );
    const unlockedColumns = LO.sortBy<LayoutColumn>(
      columns.filter(c => !c.isLocked),
      col => col.sequence,
    );
    this.viewModel.columnOptionsBound.layoutConfigs = [
      ...lockedColumns,
      ...unlockedColumns,
    ];
    this.viewModel.columnOptionsBound.DisabledIndexes = [];
    for (let i = 0; i < lockedColumns.length; i++) {
      this.viewModel.columnOptionsBound.DisabledIndexes.push(i);
    }
  }

  /**
   * This function triggers when user click on Add / (+) button.
   */
  onColumnAdd(event) {
    this.WriteDebugLog('ColumnOptionsComponent => onColumnAdd');
    let colId: number = LO.maxBy<LayoutColumn>(
      this.viewModel.columnOptionsBound.layoutConfigs,
      c => c.columnId,
    ).columnId;
    const inst = new LayoutColumn(null);
    inst.columnId = colId++;
    inst.sequence = -1;
    inst.isLocked = false;
    inst.isDefault = false;
    inst.selectedColumn = inst;
    inst.DropDownSource = this.CalculateRemainingColumns();
    this.viewModel.columnOptionsBound.layoutConfigs.push(inst);
    setTimeout(() => {
      const columnControl: any = $('.columnControl:last').find('input');
      columnControl[0].scrollIntoView();
      columnControl.focus();
    }, 0);
  }

  /**
   * Insert / Update the template in Mongo db.
   */
  onSaveLayout() {
    this.WriteDebugLog('ColumnOptionsComponent => onSaveLayout');
    this.viewModel.columnOptionsBound.layoutConfigs = this.GetSelectedColumns();
    let layoutToSave: Layout = new Layout(this.viewModel.columnOptionsBound);
    const saveData = this.processLayoutBeforeSaving(layoutToSave);
    try {
      this.columnOptionService.SaveModifiedLayout(saveData).subscribe(
        result => {
          layoutToSave.layoutID = result;
          if (this.viewModel.columnOptionsBound.isNew) {
            this.WriteDebugLog('ColumnOptionsComponent => Adding new Layout');
            this.viewModel.LayoutsInContext.push(layoutToSave);
            layoutToSave.isNew = false;
            this.WriteDebugLog(
              'Layout to save',
              new Map().set('Layout', layoutToSave),
            );
          } else {
            const foundLayout = this.viewModel.LayoutsInContext.find(
              l =>
                FMPHelper.StringEqual(l.layoutName, layoutToSave.layoutName) &&
                FMPHelper.StringEqual(l.userID, layoutToSave.userID),
            );
            if (foundLayout) {
              foundLayout.layoutID = layoutToSave.layoutID;
              foundLayout.layoutType = layoutToSave.layoutType;
              foundLayout.layoutConfigs = layoutToSave.layoutConfigs;
              foundLayout.group = layoutToSave.group;
              foundLayout.sort = layoutToSave.sort;
              foundLayout.filter = layoutToSave.filter;
              layoutToSave = foundLayout;
            } else {
              this.WriteDebugLog('ColumnOptionsComponent => Layout Not Found.');
              throwError(
                new AppError(
                  'Invalid Operation: Saved Layout not found.',
                  layoutToSave,
                ),
              );
            }
          }
          this.toasterService.ShowSuccess(`Layout successfully saved.`);
          this.columnOptionService.triggerLayoutChange(layoutToSave);
        },
        error => this.WriteDebugLog(error),
      );
    } catch (Error) {
      this.WriteDebugLog(Error);
    }
  }

  /**
   * Set group, filter and sort settings to the active layout before saving it.
   */
  private processLayoutBeforeSaving(layoutToSave: Layout): IUserProfileLayout {
    this.WriteDebugLog('ColumnOptionsComponent => processLayoutBeforeSaving');
    // layoutToSave.layoutID = LO.maxBy<Layout>(this.viewModel.LayoutsInContext, 'layoutID').layoutID + 1;
    const seletedColumns = this.gridModel.columns.filter(col =>
      LO.some<LayoutColumn>(layoutToSave.layoutConfigs, s =>
        FMPHelper.StringEqual(s.fieldName, col.field),
      ),
    );

    if (this.gridModel.GroupSettings) {
      layoutToSave.group = LO.filter<GroupDescriptor>(
        this.gridModel.GroupSettings,
        opt =>
          LO.some<ColumnComponent>(seletedColumns, s =>
            FMPHelper.StringEqual(s.field, opt.field),
          ),
      );
    } else {
      layoutToSave.group = null;
    }

    if (this.gridModel.SortSettings) {
      layoutToSave.sort = LO.filter<SortDescriptor>(
        this.gridModel.SortSettings,
        opt =>
          LO.some<ColumnComponent>(seletedColumns, s =>
            FMPHelper.StringEqual(s.field, opt.field),
          ),
      );
    } else {
      layoutToSave.sort = null;
    }
    layoutToSave.filter = this.gridModel.FilterSettings
      ? this.gridModel.FilterSettings
      : null;
    layoutToSave.userID = this.viewModel.user.ldapAlias;
    const saveData: IUserProfileLayout = {
      profileID: 0,
      userID: this.viewModel.user.ldapAlias,
      lastApplicationName: this.viewModel.application,
      isActive: true,
      layoutData: layoutToSave,
    };

    return saveData;
  }

  /**
   * This function executes when user deletes any custom layout from the template dropdown.
   */
  onLayoutDelete(event, item: Layout) {
    this.WriteDebugLog('ColumnOptionsComponent => onLayoutDelete');
    event.preventDefault();
    event.stopPropagation();
    try {
      if (!item.isDefault) {
        this.columnOptionService.deleteLayoutById(item.layoutID).subscribe(
          res => {
            LO.remove<Layout>(
              this.viewModel.LayoutsInContext,
              lay =>
                FMPHelper.StringEqual(lay.layoutName, item.layoutName) &&
                FMPHelper.StringEqual(
                  lay.userID,
                  this.viewModel.user.ldapAlias,
                ),
            );
            this.layoutDropDown.toggle(false);
            // Display success toaster message after delete the record from Mongo DB.
            this.toasterService.ShowSuccess(
              `Layout ${item.layoutName} successfully deleted.`,
            );
            const layout = FMPHelper.StringEqual(
              this.viewModel.selectedLayout.layoutName,
              item.layoutName,
            )
              ? this.viewModel.LayoutsInContext[0]
              : this.viewModel.selectedLayout;
            // Update the layout dropdown with active layout.
            this.columnOptionService.triggerLayoutChange(layout);
          },
          error => this.WriteErrorLog('Error while deleting Layout.', error),
        );
      } else {
        this.WriteWarningLog('Prevented default layout deletion.');
        this.toasterService.ShowError('Prevented default layout deletion.');
      }
    } catch (err) {
      this.WriteDebugLog(err);
    }
  }

  /**
   * Manually Detaches the angular change detection.
   */
  onCDDetach() {
    this.changeDetector.detach();
  }

  /**
   * Manually Re-attaches the angular change detection.
   */
  onCDReAttach() {
    this.changeDetector.reattach();
  }

  /**
   * This function triggers when user shift/move the possition of column by dragging the combobox control.
   */
  onDragEnd(event) {
    this.onCDReAttach();
    this.WriteDebugLog('ColumnOptionsComponent => onDragEnd');
    this.SortBoundColumns();
    const columns: LayoutColumn[] = this.GetSelectedColumns();
    this.ReCalculateAllColumnSource();
    this.changeDetector.detectChanges();
  }

  /**
   * Recalculate all column source based on selected and remaining columns in the active template.
   */
  ReCalculateAllColumnSource() {
    const columns: LayoutColumn[] = this.GetSelectedColumns();
    if (columns) {
      const remainingColumns: LayoutColumn[] = this.CalculateRemainingColumns();
      columns.forEach(item => {
        item.DropDownSource =
          item.selectedColumn &&
          item.selectedColumn.fieldName &&
          item.selectedColumn.fieldName.length > 0
            ? [item.selectedColumn, ...remainingColumns]
            : remainingColumns;
      });
    }
  }

  /**
   * Cleanup code just before Angular destroys the directive/component.
   */
  ngOnDestroy() {
    this.WriteDebugLog('ColumnOptionsComponent => ngOnDestroy');
    this.UnsubscribeObervable(this.layoutSubscription);
    this.UnsubscribeObervable(this.layoutNameChangedSubscription);
  }
}
