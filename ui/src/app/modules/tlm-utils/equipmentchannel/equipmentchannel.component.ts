/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */
import { Component, OnInit, OnDestroy, Input } from '@angular/core';
import { BaseComponent } from '../../../base/component/base/base.component';
import { LoggerService } from '../../../base/service/logger.service';
import { DataPoint } from './models/timeseries';
import { EquipmentChannelService } from './equipmentchannel.service';
import 'hammerjs';
import { DatePipe } from '@angular/common';
import { Equipment } from '../models/equipment-model';
import { EqRegistryResponse } from './models/eq-registry';


@Component({
    selector: 'app-tlm-utils-equipmentchannel',
    templateUrl: './equipmentchannel.component.html',
    styleUrls: ['./equipmentchannel.component.scss'],
})
export class EquipmentChannelComponent extends BaseComponent implements OnInit, OnDestroy {

    // The equipment list and the subsequently selected equipment comes as an input to this (from child component, EquipmentBrowser to this one as an event emission).
    equipmentList: Equipment[] = [];
    selectedEquipment: Equipment[] = [];
    headerLabel: string = "No Channel Data"
    loadingLabel: string = '';
    channelList: any[] = [];
    channelDataTypes: string[] = ['raw', 'measure points', 'episodic'];
    channelCount: number = 0;
    channelData: any[] = [];
    channelDataPoints: DataPoint[] = [];
    selectedChannelName: string = "";
    channelTimeStamps: any[] = [];
    channelDataValues: number[] = [];
    noAccessMsg: string = "";
    equipmentID: string = 'SBF62411A0608';
    materialNumber: string = '100196736';
    datePipe = new DatePipe('en-US');

    @Input() incomingEquipment: Equipment = null;

    constructor(
        loggerService: LoggerService,
        public equipmentChannelService: EquipmentChannelService,
    )
    {
        super('EquipmentChannelComponent', loggerService);
    }

    ngOnInit() {

        this.clearChannelData();
        this.equipmentList = null;
        this.selectedEquipment = null;
        this.refreshData();
        
    }
    refreshData() {
        if (this.incomingEquipment != null) {
            this.selectedEquipment = [];
            this.selectedEquipment[0] = this.incomingEquipment;
            this.getChannelListProcess(this.incomingEquipment);
        }
    }
    clearChannelData() {
        this.channelList = [];
        this.channelDataValues = [];
        this.channelCount = 0;
        this.channelData = [];
        this.channelTimeStamps = [];
        this.channelDataValues = [];
        this.selectedChannelName = null;
        this.headerLabel = "No Channel Data";
        this.loadingLabel = '';
    }
    onEquipmentArrayEmission(incomingEquipmentArray: Equipment[]) {
        this.clearChannelData();
        this.equipmentList = incomingEquipmentArray;
        this.selectedEquipment = null;
    }
    onEquipmentSelectedEmission(selectedEquipment: Equipment[]) {
        this.clearChannelData();
        this.selectedEquipment = selectedEquipment;
        this.processEquipmentSelectionFromGrid();
    }

    processEquipmentSelectionFromGrid() {
        this.getChannelListProcess(this.selectedEquipment[0]);
    }

    onChannelChange(event) {

        // our event value here is the two element array... so we get the first element which is the name and the second elment is the type of value i.e. float
        this.selectedChannelName = event.target.value;
        this.getEquipmentChannelData(this.incomingEquipment, this.selectedChannelName, '');
    }

    getEquipmentChannelData(
        equipment: Equipment,
        channelCode: string,
        channelType: string) : void
    {
        this.loadingLabel = 'attempting to retrieve channel data for ' + channelCode + ' ...';
        this.equipmentChannelService.getChannelData(
            equipment,
            channelCode,
            channelType).subscribe(
            incomingChannelData => {

                if (incomingChannelData.rows && incomingChannelData.rows.length > 0)
                {
                    
                    this.channelData = incomingChannelData.rows;
                    this.channelTimeStamps = [this.channelData.length];
                    this.channelDataValues = [this.channelData.length];
                    this.channelDataPoints = new Array<DataPoint>(this.channelData.length);

                    // we may need to parse out the values here... they are coming back as the name and a type i.e. Pressure, float
                    for (let i = 0; i < this.channelData.length; i++) {
                        let pointTime = this.channelData[i][0];// timestamp
                        let pointValue = this.channelData[i][1];// values
                        this.channelTimeStamps[i] = this.datePipe.transform(pointTime, "MM/dd/yyyy : HH:mm:ss Z");
                        this.channelDataValues[i] = pointValue;
                        this.channelDataPoints[i] =
                            {
                                Date: pointTime,
                                DataValue: pointValue
                            }
                    }
                    this.WriteInfoLog('retrieved channel data');
                    this.ToasterServiceInstace.ShowInformation('retrieved channel data for ' + channelCode);
                    this.loadingLabel = channelCode + ' loaded.';
                }
                else   {
                 
                    this.ToasterServiceInstace.ShowInformation('no data found.');
                }
            },
            error => {
                this.WriteErrorLog('error in getChannelData subscribe', error);
                this.ToasterServiceInstace.ShowWarning('Something Went wrong.');
                this.loadingLabel = 'error getting data';
            },
        );
    }

    // This gets the channel list, but before doing so, it verifies the equipment is in the mock registry first. If not, it adds it.
    // If it is already there, then it proceeds to get channel list.
    getChannelListProcess(equipment: Equipment) {

        this.equipmentChannelService.verifyEquipmentExistsInRegistry(equipment).subscribe(
            eqInstance => {
                this.getChannelList(equipment);
            },
            error => {
                //this.registerEquipment(equipment);
                this.WriteErrorLog('error in verifying Equipment\'s wke with id '+equipment.id, error);
                this.ToasterServiceInstace.ShowError('error in verifying Equipment\'s wke with id '+equipment.id);
                return false;
            },
        );
    }
    registerEquipment(equipment: Equipment) {
        this.equipmentChannelService.registerEquipmentInRegistry(equipment).subscribe(
            resp => {

                let eqRegResp: EqRegistryResponse = resp;
                // check on the resp having an id.
                if (eqRegResp.id && eqRegResp.id.length > 0) {

                    this.getChannelList(equipment);
                }
                else {
                    this.ToasterServiceInstace.ShowWarning('Error verifying Equipment Registry for' + equipment.materialNumber + ':' + equipment.sourceSystemRecordId);
                }
            },
            error => {
                this.WriteErrorLog('error in registering Equipment', error);
                this.ToasterServiceInstace.ShowWarning('Error registering Equipment in Registry for' + equipment.materialNumber + ':' + equipment.sourceSystemRecordId);
                return false;
            },
        );
    }
    getChannelList(equipment: Equipment) {

        this.equipmentChannelService.getChannelList(equipment).subscribe(
            channels => {
                this.channelList = channels;
                this.channelCount = this.channelList.length;

                if (this.channelCount && this.channelCount > 0) {
                    this.headerLabel = 'Channel Data is Available';
                    this.WriteInfoLog('retrieved channel definition data');
                    this.ToasterServiceInstace.ShowInformation('retrieved channel definition data for ' + equipment.materialNumber + ':' + equipment.equipmentCode);

                    // do a default channel select
                    if (this.selectedChannelName == null) {
                        let result = this.channelList.find((c) => c.code === "CMPR.kPa");
                        if (result) {
                            this.selectedChannelName = result.code;
                            this.getEquipmentChannelData(this.incomingEquipment, this.selectedChannelName, '');
                        }
                    }
                    else {
                        this.getEquipmentChannelData(this.incomingEquipment, this.selectedChannelName, '');
                    } 
                }
                else {
                    //this.ToasterServiceInstace.ShowWarning(' channel definitions for' + equipment.wellKnownEntityId+ ' not found');

                }
       
                
            },
            error => {
                this.WriteErrorLog('error in getChannelList', error);
                this.ToasterServiceInstace.ShowWarning(' channel definitions for' + equipment.wellKnownEntityId +' API error');
            },
        );
    }
    /**
     * We are clearing everything here
     */
    ngOnDestroy() {
        this.equipmentList = [];
        this.selectedEquipment = [];
        this.clearChannelData();
    }
}
