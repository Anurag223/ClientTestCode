/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */

import {
    Component, OnInit, OnDestroy, Input, Output, EventEmitter,
    ChangeDetectionStrategy,
    ChangeDetectorRef,
    OnChanges,
    Renderer2,
    ViewChild,
    AfterViewInit,
} from '@angular/core';
import { BaseComponent } from '../../../base/component/base/base.component';
import { LoggerService } from '../../../base/service/logger.service';
import { EpicV3Service } from './epicV3.service';
import { IEpicAPIResponse, Group, EpicClassication, ProductLine, SubProductLine, ProductFamily, Technology, Brand, EquipmentSystem, Attribute } from './epic-modelV3';
import { process } from '@progress/kendo-data-query';
import { DataStateChangeEvent, GridComponent, ColumnComponent, PageChangeEvent } from '@progress/kendo-angular-grid';
import { GridConfigModel, GridPagerConfigModel } from '../../../sharedcomponents/models/sharedmodels';
import { Observable ,  of } from 'rxjs';
import { flatten } from '@angular/compiler';
import { XLSXExportService } from '../../../sharedcomponents/xlsx-exporter/xlsx-export-service';



@Component({
    selector: 'app-tlm-utils-epicV3',
    templateUrl: './epicV3.component.html',
    styleUrls: ['./epicV3.component.scss'],
})
export class EpicV3Component extends BaseComponent implements OnInit, OnDestroy, OnChanges, AfterViewInit {
    epicGroups: Group[] = [];
    flattennedRows: any = [];
    treeData: any[] = [];
    loadingLabel: string = '';
    isTreeView: boolean = true;
    toggleLabel: string = (this.isTreeView ? 'Toggle to Grid View':'Toggle to Tree View')
    expandedKeys: any[] = ['1', '1_1', '1_1_0', '1_1_0_0'];
    selectedKeys: any[] = [];
    selectedName: string = '';
    selectedVersion: any

    // convenience for potential drop downs
    groups: any[] = [];
    productLines: any[] = [];
    subProductLines: any[] = [];
    productFamilies: any[] = [];
    technologies: any[] = [];
    brands: any[] = [];
    equipSystems: any[] = [];
    gridAttributes: Attribute[] = [];
    showEpic: boolean = true;
    versions:any[]=[];

    // grid props
    gridModel: GridConfigModel;
    btnCount = 3;
    height = 300;
    pageSizes = [20, 50, 100];
    gridData: any = [];
    aboveGridMargin = 65;
    @ViewChild(GridComponent, { static: false }) epicgrid: GridComponent;


    // THE Output of this component is the browsed-for epic data
    @Output() epicArrayEmission = new EventEmitter<Group[]>();
    // Also output is the selections made from the browser
    @Output() selectedEpicTreeEmission = new EventEmitter<Group[]>();
    // Output from the grid
    @Output() selectedEpicGridEmission = new EventEmitter<EpicClassication[]>();


    // pass in the show the epic selectors 
    @Input() displayEpicDropDowns: boolean = false;

    // Pass in the view epic flag
    @Input()
    set viewEpicComponentFlag(flag: boolean) {
        this.showEpic = (flag && flag == true) || false;
    }
    // used to make sure the grid fills up the screen.... this one is for the space above the grid.
    @Input()
    set topGridMargin(val: number) {
        this.aboveGridMargin = val;
    }
    get viewEpicComponentFlag(): boolean { return this.showEpic; }


    constructor(
        loggerService: LoggerService,
        private changeDetector: ChangeDetectorRef,
        public epicService: EpicV3Service,
        private excelService: XLSXExportService,
        private renderer: Renderer2,
    ) {
        super('EpicV3Component', loggerService);
    }
    
    ngOnChanges() {
        this.WriteInfoLog("showEpic="+this.showEpic); // logs undefined
    }
    ngOnInit() {
        this.initGridModel();
        this.epicGroups = <Group[]>{}; 
        this.getEpicDataAsObject();
        this.WriteInfoLog('viewEpicComponentFlag = ' + this.viewEpicComponentFlag + ', displayEpicDropDowns = ' + this.displayEpicDropDowns);
    }

       toggleView() {
        this.isTreeView = !this.isTreeView;
        this.toggleLabel = (this.isTreeView ? 'Toggle to Grid View' : 'Toggle to Tree View');
        if (!this.isTreeView) // create grid data
        {
            this.flattennedRows = this.flattenEpic(this.epicGroups);
            this.gridData = process(this.flattennedRows, this.gridModel.GridState);
        }
        this.onResize();
    }
    /**
 * This method is used to set the grid height dynamically
 *
 */
    onResize() {
        this.WriteDebugLog('EpicComponent => onResize');
        const tableH = window.innerHeight;
        this.gridModel.gridHeight = tableH - this.aboveGridMargin; // 65 or the passed in param;
    }

    getwindowHeight()
    {
        
    }
    /**
    * Manually Detaches the angular change detection.
    *
    */
    onCDDetach() {
        this.changeDetector.detach();
    }

    /**
     * Manually Re-attaches the angular change detection.
     *
     */
    onCDReAttach() {
        this.changeDetector.reattach();
        this.changeDetector.detectChanges();
    }
    /**
    * This method is triggerd when the user changes the pagination
    *
    * @param pageChange PageChangeEvent
    */
    public pageChange(pageChange: PageChangeEvent): void {
        this.onCDDetach();
        this.gridModel.skip = pageChange.skip;
        this.gridModel.take = pageChange.take;
        this.onResize();
        this.onCDReAttach();
    }
    ngAfterViewInit() {
        this.WriteDebugLog('EpicComponent => ngAfterViewInit');
        if (!this.isTreeView && this.epicgrid.columnList) {
            // get the master column list for Grid
            this.gridModel.columns = this.epicgrid.columns.toArray() as ColumnComponent[];
            this.gridModel.DataGridInstance = this.epicgrid;
            this.changeDetector.detectChanges();
            this.onResize();
        }
    }
    public isItemSelected(_: any, index: string): boolean {
        if (this.selectedKeys && this.selectedKeys.indexOf(index) > -1) {
            return true;
        }
        return false;
    }

    // These are node items that can be any level... not really Groups.
    // We should change this to a more appropriate node type
    public handleSingleSelectionFromTree(event): void {

        if (this.isItemSelected) {
            this.selectedKeys = event.index;

            let selectedItems: Group[] = [];
            selectedItems[0] = event.dataItem;

            // output to anyone who cares (parent components ;)
            this.selectedEpicTreeEmission.emit( selectedItems );

        }

    }
    // These emitted items are row items from Grid and always  
    public handleMultiSelectionFromGrid(event): void {


        if (this.isItemSelected) {

            let selectedEpics: EpicClassication[] = [];
            for (let i = 0; i < event.selectedRows.length; i++) {
                selectedEpics[i] = event.selectedRows[i].dataItem;
            }
            // output to anyone who cares (parent components ;)
            this.selectedEpicGridEmission.emit(selectedEpics);

        }

    }
    exportAsXLSX(): void {
        if (this.flattennedRows.length == 0) {
            this.flattenEpic(this.epicGroups);
        }
        this.excelService.exportAsExcelFile(this.flattennedRows, 'epic-data');
    }
    // get all Epic
    getEpicDataAsObject() {

        this.loadingLabel = "loading EPIC Data...";
        let eventStartTime = new Date();
        this.epicService.getEpicObject(
            1, // page
            25, // size           
            null, // sort
            "attributes", //includes attributes from v3 api
            
        ).subscribe(
            incomingEpic => {
                let duration = new Date().valueOf() - eventStartTime.valueOf();
                this.epicGroups = incomingEpic.collection; 
                this.treeData = incomingEpic.collection;
               
                if (this.epicGroups && this.epicGroups.length > 0) {
                    this.WriteInfoLog(this.epicGroups.length + ' groups for inputs found');
                    this.ToasterServiceInstace.ShowInformation('found ' + this.epicGroups.length + ' groups in ' + duration / 1000 + ' sec');
                    this.loadingLabel = '';

                    // do stuff to show the grid or the tree view
                    //this.flattennedRows = this.flattenEpic(this.epicGroups);

                    // output to anyone who cares (parent components ;)
                    this.epicArrayEmission.emit(this.epicGroups);
                    this.dataStateChange(this.gridModel.GridState);
                }
                else {
                    this.loadingLabel = '';
                    this.ToasterServiceInstace.ShowError('groups not found');
                }

            },
            error => {
                this.loadingLabel = '';
                this.WriteErrorLog('error in getEpicDataAsObject subscribe', error);
                this.ToasterServiceInstace.ShowError('Something Went wrong.');
            },
        );
    }

  
    // This is used by the kendo treeview (called from template)
    public fetchChildren(node: any): Observable<any[]> {
        //Return the items collection of the parent node as children.
        //Return attributes if node is 7th level and has attributes
        //return of(node.items);  
        if(node.children && node.children.length>0) {     
        return of(node.children);
        }
        else if(node.attributes  && node.attributes.length>0 ){               
        return of(node.attributes);
        }
    }
   
    // This is used by the kendo treeview (called from template)
    public hasChildren(node: any): boolean {        
        //Check if node has attributes
        //Check if the parent node has children.
        // return node.items && node.items.length > 0;
         return node.children && node.children.length > 0 || node.attributes && node.attributes.length>0
    }
    public dataStateChange(state: DataStateChangeEvent): void {
        if (state) {
            this.changeDetector.detach();
            this.gridModel.take = state.take;
            this.gridModel.skip = state.skip;
            if (state && state.group) {
                // If the Grouping is applied on more than 10 Groups then display a toaster message
                if (state.group.length > 10) {
                    this.ToasterServiceInstace.ShowError(
                        'You can not group more than 10 columns',
                    );
                    state.group.splice(state.group.length - 1, 1);
                }
            }
            this.gridModel.GroupSettings = state.group ? state.group.slice() : null;
            this.gridModel.SortSettings = state.sort ? state.sort.slice() : null;
            this.gridModel.FilterSettings = state.filter;
            this.gridData = process(this.flattennedRows, this.gridModel.GridState);
            this.changeDetector.markForCheck();
            this.changeDetector.reattach();
        }
    }
    public initGridModel() {
        this.gridModel = new GridConfigModel();
        this.gridModel.skip = 0;
        this.gridModel.take = 20;

        this.gridModel.GridDateFields = ['lastUpdatedDateTime', 'createdDate'];
        this.gridModel.defaultPageSize = this.pageSizes[0];
        this.gridModel.isPagingEnabled = true;
        this.gridModel.isColumnResizingEnabled = true;
        this.gridModel.isFilteringEnabled = true;
        this.gridModel.isGroupingEnabled = true;
        this.gridModel.isColumnReOrderEnabled = true;
        this.gridModel.sorting = { mode: 'multiple' };
        this.gridModel.isSortingEnabled = true;
        this.gridModel.GroupSettings = [];
        // add a default filter for TBD (may want to pass this in as an input
        this.gridModel.pager = new GridPagerConfigModel();
        this.gridModel.pager.buttonCount = 5;
        this.gridModel.pager.pageSizeOptions = this.pageSizes;

        this.dataStateChange({
            take: this.gridModel.take,
            skip: this.gridModel.skip,
        });
       // this.onResize();
    }
    /**
     * We are clearing everything here
     */
    ngOnDestroy() {
        this.epicGroups = <Group[]>{};
    }
    // for grid, we need to flatten out the hiearchy and create a new row for every leaf
    // the following monstrosity could probably be refactored into functions
    
    public flattenEpic(epicGroups: Group[]): any[] {
        let flattenedRows: EpicClassication[] = [];
        let rowIndex: number = -1;

        // get groups
        if (epicGroups && epicGroups.length > 0) {
            for (let groupIndex = 0; groupIndex < epicGroups.length; groupIndex++) {
               
                let epicGroup: Group = epicGroups[groupIndex];                
                this.groups.push(epicGroup.code);

                // get product lines
                if (epicGroup.children && epicGroup.children.length > 0) {
                    let productLines: ProductLine[] = epicGroup.children;
                    for (let plIndex = 0; plIndex < productLines.length; plIndex++) {
                        let productLine: ProductLine = productLines[plIndex];
                        this.productLines.push(productLine.code);

                        // get sub product lines
                        if (productLine.children && productLine.children.length > 0) {
                            let subProductLines: SubProductLine[] = productLine.children;
                            for (let subPLIndex = 0; subPLIndex < subProductLines.length; subPLIndex++) {
                                let subProductLine: SubProductLine = subProductLines[subPLIndex];
                                this.subProductLines.push(subProductLine.code);

                                // get product families
                                if (subProductLine.children && subProductLine.children.length > 0) {
                                    let productFamilies: ProductFamily[] = subProductLine.children;
                                    for (let pfIndex = 0; pfIndex < productFamilies.length; pfIndex++) {
                                        let productFamily: ProductFamily = productFamilies[pfIndex];
                                        this.productFamilies.push(productFamily.code);

                                        // get technology product lines
                                        if (productFamily.children && productFamily.children.length > 0) {
                                            let technologies: Technology[] = productFamily.children;
                                            for (let techPLIndex = 0; techPLIndex < technologies.length; techPLIndex++) {
                                                let technology: Technology = technologies[techPLIndex];
                                                this.technologies.push(technology.code);

                                                // get brands
                                                if (technology.children && technology.children.length > 0) {
                                                    let brands: Brand[] = technology.children;
                                                    for (let brandIndex = 0; brandIndex < brands.length; brandIndex++) {
                                                        let brand: Brand = brands[brandIndex];
                                                        this.brands.push(brand.code);

                                                        // get equipment systems
                                                        if (brand.children && brand.children.length > 0) {
                                                            
                                                            let equipmentSystems: any[] = brand.children; // fix the any
                                                            for (let eqSysIndex = 0; eqSysIndex < equipmentSystems.length; eqSysIndex++) {
                                                                let equipmentSystem: EquipmentSystem = equipmentSystems[eqSysIndex];
                                                                this.equipSystems.push(equipmentSystem.code);
																
																
                                                                 // get toolname attribute 
                                                                if (equipmentSystems[eqSysIndex].attributes && equipmentSystems[eqSysIndex].attributes.length > 0) {
                                                                    
                                                                    let attributes: any[] = equipmentSystems[eqSysIndex].attributes.filter(
                                                                        att => att.code === "ToolName");

                                                                    for (let attrIndex = 0; attrIndex < attributes.length; attrIndex++) {
                                                                       
                                                                        let attribute: Attribute = attributes[attrIndex];
                                                                        this.gridAttributes.push(attribute);

                                                                // At the last leaf, now build the row object
                                                                let epicRow: EpicClassication = {
                                                                    type: equipmentSystem.type,
                                                                    division: epicGroup.name,
                                                                    businessLine: productLine.name, // used to be segment
                                                                    subBusinessLine: subProductLine.name, // used to be subsegment
                                                                    productFamily: productFamily.name,
                                                                    technology: technology.name, // used to be product line
                                                                    brand: brand.name,
                                                                    equipmentSystem: equipmentSystem.name, // used to be equipment code
                                                                    name: equipmentSystem.name,
                                                                    id: equipmentSystem.id,
                                                                    toolNameAttribute: attribute.value
                                                                }
                                                                rowIndex++;
                                                                flattenedRows[rowIndex] = epicRow;
																}  //end loop over attributes
																}// end if on equipmentSystem.children
																
																else
																{
																let epicRow: EpicClassication = {
                                                                id: brand.id,
                                                                type: brand.type,
                                                                division: epicGroup.name,
                                                                businessLine: productLine.name,
                                                                subBusinessLine: subProductLine.name,
                                                                productFamily: productFamily.name,
                                                                technology: technology.name,
                                                                brand: brand.name,
                                                                name: brand.name,                                                                
                                                                equipmentSystem: '',
                                                                toolNameAttribute:''
                                                            }
                                                            rowIndex++;
                                                            flattenedRows[rowIndex] = epicRow;
																}

                                                            } // end loop over equip systems
                                                        }// end if on if brand.children
                                                        else {
                                                            let epicRow: EpicClassication = {
                                                                id: brand.id,
                                                                type: brand.type,
                                                                division: epicGroup.name,
                                                                businessLine: productLine.name,
                                                                subBusinessLine: subProductLine.name,
                                                                productFamily: productFamily.name,
                                                                technology: technology.name,
                                                                brand: brand.name,
                                                                name: brand.name,                                                                
                                                                equipmentSystem: '',
                                                                toolNameAttribute:''
                                                            }
                                                            rowIndex++;
                                                            flattenedRows[rowIndex] = epicRow;
                                                        }
                                                    }// end loop over brands
                                                } // end if on if technology.children
                                                else {
                                                    let epicRow: EpicClassication = {
                                                        id: technology.id,
                                                        type: technology.type,
                                                        division: epicGroup.name,
                                                        businessLine: productLine.name,
                                                        subBusinessLine: subProductLine.name,
                                                        productFamily: productFamily.name,
                                                        technology: technology.name,
                                                        name: technology.name,
                                                        brand: '',
                                                        equipmentSystem: '',
                                                        toolNameAttribute:''
                                                    }
                                                    rowIndex++;
                                                    flattenedRows[rowIndex] = epicRow;
                                                }
                                            }// end loop over tech product lines 
                                        } // end if on productFamily.children
                                        else {
                                            let epicRow: EpicClassication = {
                                                id: productFamily.id,
                                                type: productFamily.type,
                                                division: epicGroup.name,
                                                businessLine: productLine.name,
                                                subBusinessLine: subProductLine.name,
                                                productFamily: productFamily.name,
                                                name: productFamily.name,
                                                technology: '',
                                                brand: '',
                                                equipmentSystem: '',
                                                toolNameAttribute:''
                                            }
                                            rowIndex++;
                                            flattenedRows[rowIndex] = epicRow;
                                        }
                                    } // end loop over product families
                                } // end if subProductLine.children
                                else {
                                    let epicRow: EpicClassication = {
                                        id: subProductLine.id,
                                        type: subProductLine.type,
                                        division: epicGroup.name,
                                        businessLine: productLine.name,
                                        subBusinessLine: subProductLine.name,
                                        name: subProductLine.name,
                                        productFamily: '',
                                        technology: '',
                                        brand: '',
                                        equipmentSystem: '',
                                        toolNameAttribute:''
                                    }
                                    rowIndex++;
                                    flattenedRows[rowIndex] = epicRow;
                                }
                            } // end loop over sub product lines
                        } // end if on productline.children
                        else {
                            let epicRow: EpicClassication = {
                                id: productLine.id,
                                type: productLine.type,
                                division: epicGroup.name,
                                businessLine: productLine.name,
                                name: productLine.name,
                                subBusinessLine: '',
                                productFamily: '',
                                technology: '',
                                brand: '',
                                equipmentSystem: '',
                                toolNameAttribute:''
                            }
                            rowIndex++;
                            flattenedRows[rowIndex] = epicRow;
                        }
                    } // end loop over product lines
                } // end if on epicGroup.children
                else {
                    let epicRow: EpicClassication = {
                        id: epicGroup.id,
                        type: epicGroup.type,
                        division: epicGroup.name,
                        name: epicGroup.name,
                        businessLine: '',
                        subBusinessLine: '',
                        productFamily: '',
                        technology: '',
                        brand: '',
                        equipmentSystem: '',
                        toolNameAttribute:''
                    }
                    rowIndex++;
                    flattenedRows[rowIndex] = epicRow;
                }
            } // end loop over epic groups
        
    }// end if on if groups
        else {
            // no epic data is available

        }
        return flattenedRows;
    }


}
