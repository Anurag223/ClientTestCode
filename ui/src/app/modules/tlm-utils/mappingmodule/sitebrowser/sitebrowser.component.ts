/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */
import {
    Component,
    OnInit,
    Input,
    OnDestroy,
    ChangeDetectionStrategy,
    ChangeDetectorRef,
    ViewChild,
} from '@angular/core';
import { BaseComponent } from '../../../../base/component/base/base.component';
import { LoggerService } from '../../../../base/service/logger.service';

import * as _ from 'lodash';
import { UserprofileService } from '../../../../base/userprofile/userprofile.service';
import { FMPHelper } from '../../../../../Constants/helpers';
import { Router } from '@angular/router';

import {
    IWhitelistedSiteModel,
    ISitePermission,
    EnabledSites,
    WhiteListedSites,
} from '../models/sitebrowser-model';

import { Observable ,  of ,  Subscription } from 'rxjs';
import {
    GridConfigModel,
    GridPagerConfigModel,
} from '../../../../sharedcomponents/models/sharedmodels';
import { process } from '@progress/kendo-data-query';
import { DataStateChangeEvent } from '@progress/kendo-angular-grid';
import { LoaderService } from '../../../../base/loader/loader.service';
import { FMPConstant } from '../../../../../Constants/constant';
import { SiteDetailsService } from '../../../../base/userprofile/sitedetails.service';
import { SiteBrowserService } from './sitebrowser.service';


@Component({
    selector: 'app-tlm-utils-sitebrowser',
    templateUrl: './sitebrowser.component.html',
    styleUrls: ['./sitebrowser.component.scss'],
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SiteBrowserComponent extends BaseComponent
    implements OnInit, OnDestroy {
    public gridModel: GridConfigModel;
    public pageSizes = [100, 500, 1000];
    public btnCount = 3;
    public height = 800;
    public gridData: any = [];
    public allSiteData: any = [];
    public allEnabledSites: Array<EnabledSites>;
    public selectedSites: any = {};
    private setModifedData: any = {};
    private patchData: any = {};
    public pnsAppName = FMPConstant.planandSchedule;
    public amAppName = FMPConstant.activityMonitor;
    public canSave = false;
    public editPermision = 'edit';
    public viewPermision = 'view';
    ldap: string;
    @Input() siteData;
    siteApiSubscription: Subscription;
    siteApiErrorSubscription: Subscription;
    copyAllSites: any;
    rollbackNewSites: WhiteListedSites[] = [];
    rollbackPatchSites: WhiteListedSites[] = [];
    showEnabledSitesError = false;
    filteredEnabledSites: EnabledSites[] = [];
    appNames: Array<string> = [];
    disabledCheckboxMsg = 'Site is not enabled on Mateo';

  public groupData: any[] = [];
  public dbList: any[] = [];
  public expandedKeys: any[] = ['0', '1'];
  public selectedKeys: any[] = ['0_1'];

  constructor(
      loggerService: LoggerService,
      private loaderService: LoaderService,
      private changeDetector: ChangeDetectorRef,
      public siteBrowserService: SiteBrowserService,
      private userProfileService: UserprofileService,
      private siteApi: SiteDetailsService,
      private router: Router,
  ) {
      super('SiteBrowserComponent', loggerService);
  }

  ngOnInit() {
      this.allEnabledSites = [];
      this.initGridModel();
      this.fetchWhitelistedSites();
      this.ldap = this.userProfileService.dataModel.LDAP;
  }
    public dataStateChange(state: DataStateChangeEvent): void {
        if (state) {
            this.changeDetector.detach();
            this.gridModel.take = state.take;
            this.gridModel.skip = state.skip;
            if (state && state.group) {
                // If the Grouping is applied on more than 10 Groups then display a toaster message
                if (state.group.length > 10) {
                    this.ToasterServiceInstace.ShowError(
                        'You can not group more than 10 columns',
                    );
                    state.group.splice(state.group.length - 1, 1);
                }
            }
            this.gridModel.GroupSettings = state.group ? state.group.slice() : null;
            this.gridModel.SortSettings = state.sort ? state.sort.slice() : null;
            this.gridModel.FilterSettings = state.filter;
            this.gridData = process(this.allSiteData, this.gridModel.GridState);
            this.changeDetector.markForCheck();
            this.changeDetector.reattach();
        }
    }
    public initGridModel() {
        this.gridModel = new GridConfigModel();
        this.gridModel.skip = 0;
        this.gridModel.take = 100;
        this.gridModel.GridDateFields = ['lastUpdatedDateTime', 'createdDate'];
        this.gridModel.defaultPageSize = 100;
        this.gridModel.isPagingEnabled = true;
        this.gridModel.isColumnResizingEnabled = true;
        this.gridModel.isFilteringEnabled = true;
        this.gridModel.isGroupingEnabled = true;
        this.gridModel.isColumnReOrderEnabled = true;
        this.gridModel.sorting = { mode: 'multiple' };
        this.gridModel.isSortingEnabled = true;
        this.gridModel.GroupSettings = [];

        this.gridModel.pager = new GridPagerConfigModel();
        this.gridModel.pager.buttonCount = 5;
        this.gridModel.pager.pageSizeOptions = [100, 500, 1000];
        this.dataStateChange({
            take: this.gridModel.take,
            skip: this.gridModel.skip,
        });
    }

    public doNothing() {
    }
    public getAllSites() {
        this.loaderService.showSpinner();
        this.siteApi.getAllSites();
        // Subscibe to mateo site api service and add siteid to profile object
        this.siteApiSubscription = this.siteApi.sitesApiObservable.subscribe(
            siteDetails => {
                this.WriteDebugLog(
                    'Site Details Received.',
                    new Map().set('Site', siteDetails),
                );
                this.fetchEnabledSites(siteDetails);
            },
            err => {
                this.WriteErrorLog('Error fetching site details.', err);
                this.ToasterServiceInstace.ShowError('Something Went wrong.');
                this.loaderService.hideSpinner();
            },
        );

        this.siteApiErrorSubscription = this.siteApi.sitesErrorObservable.subscribe(
            error => {
                this.WriteErrorLog(
                    'Failed to fetch data for Site',
                    new Map().set('ERROR', error),
                );
                this.loaderService.hideSpinner();
            },
            err => {
                this.WriteErrorLog('Error while handeling Site Error Observable.', err);
                this.ToasterServiceInstace.ShowError('Something Went wrong.');
                this.loaderService.hideSpinner();
            },
        );
    }
    public fetchEnabledSites(siteDetails) {
        let sites: any;
        // Get Enabled Sites
        this.siteBrowserService.getEnabledSites().subscribe(
            (response: Array<any>) => {
                this.allEnabledSites = response;
                if (siteDetails) {
                    this.allSiteData = [];
                    sites = siteDetails.map(data => {
                        const selectedSite = this.selectedSites[data.site.code];
                        this.setPermissionToSiteObject(selectedSite, data.site);
                        data.site.siteCreatedBy = selectedSite && selectedSite.createdBy;
                        data.site.siteCreatedDate =
                            selectedSite && new Date(selectedSite.createdDateTime);
                        data.site.lastUpdatedBy =
                            selectedSite && selectedSite.lastUpdatedBy;
                        data.site.lastUpdatedDateTime =
                            selectedSite && new Date(selectedSite.lastUpdatedDateTime);
                        data.site.createdDate =
                            data.site.createdDate && new Date(data.site.createdDate);
                        return data.site;
                    });
                    this.allSiteData = sites;
                    this.copyAllSites = _.cloneDeep(this.allSiteData);
                    this.dataStateChange(this.gridModel.GridState);
                    this.loaderService.hideSpinner();
                }
            },
            () => {
                this.ToasterServiceInstace.ShowError('Something Went wrong.');
            },
        );
    }
    public checkboxStateChanged(data: IWhitelistedSiteModel) {
        if (this.selectedSites.hasOwnProperty(data.code)) {
            this.updateExistingSitePermission(data);
        } else {
            this.newSitesToAdd(data);
        }
        this.canSave = true;
    }

    private updateExistingSitePermission(data: any) {
        this.patchData[data.code] = this.patchData[data.code]
            ? this.patchData[data.code]
            : {};
        this.patchData[data.code].data = data;
        this.patchData[data.code].siteCode = data.code;
        const pnsPermission = {
            applicationName: FMPConstant.planandSchedule,
            view: data.pnsview || false,
            edit: data.pnsedit || false,
        };
        const amPermission = {
            applicationName: FMPConstant.activityMonitor,
            view: data.amview || false,
            edit: data.amedit || false,
        };
        this.patchData[data.code].whiteListedSitePermissionsList = [];
        this.patchData[data.code].whiteListedSitePermissionsList.push(
            pnsPermission,
        );
        this.patchData[data.code].whiteListedSitePermissionsList.push(amPermission);
    }

    private newSitesToAdd(data: any) {
        this.setModifedData[data.code] = this.setModifedData[data.code]
            ? this.setModifedData[data.code]
            : {};
        this.setModifedData[data.code].data = data;
        this.setModifedData[data.code].code = data.code;
        this.setModifedData[data.code].facilityId =
            data.facility && data.facility.id;
        this.setModifedData[data.code].segmentCode = data.segmentCode;
        this.setModifedData[data.code].activeCMMS = data.activeCMMS;
        this.setModifedData[data.code].businessCode =
            data.businessView && data.businessView.code;
        this.setModifedData[data.code].businessGroup =
            data.businessView && data.businessView.businessGroup;

        const pnsPermission = {
            applicationName: FMPConstant.planandSchedule,
            view: data.pnsview || false,
            edit: data.pnsedit || false,
        };
        const amPermission = {
            applicationName: FMPConstant.activityMonitor,
            view: data.amview || false,
            edit: data.amedit || false,
        };
        this.setModifedData[data.code].permissions = [];
        this.setModifedData[data.code].permissions.push(pnsPermission);
        this.setModifedData[data.code].permissions.push(amPermission);
    }

    public fetchWhitelistedSites() {
        this.siteBrowserService.getWhitelistedSites().subscribe(
            (response: Array<any>) => {
                if (response) {
                    this.selectedSites = response.reduce(
                        (acc, cur: IWhitelistedSiteModel) => {
                            acc[cur.code] = this.restructureDataForPopulation(cur);
                            return acc;
                        },
                        {},
                    );

                    this.getAllSites();
                }
            },
            () => {
                this.ToasterServiceInstace.ShowError('Something Went wrong.');
            },
        );
    }

    public saveWhitelistedSites() {
        if (!_.isEmpty(this.setModifedData)) {
            const dataToSend = _.cloneDeep(this.setModifedData);
            Object.values(dataToSend).forEach((site: any) => {
                this.selectedSites[site.code] = _.cloneDeep(site);
                this.selectedSites[site.code].data = this.setModifedData[
                    site.code
                ].data;
                this.restructureDataForPopulation(dataToSend[site.code]);
                delete dataToSend[site.code].data;
            });
            this.siteBrowserService
                .setWhitelistedSites(Object.values(dataToSend))
                .subscribe(
                    (response: any) => {
                        this.ToasterServiceInstace.ShowSuccess('Sites Saved Successfully.');
                        this.setModifedData = {};
                        this.patchData = {};
                        this.canSave = false;
                        this.changeDetector.detectChanges();
                    },
                    (err: any) => {
                        this.ToasterServiceInstace.ShowError('Something Went wrong.');
                    },
            );
        }
        if (!_.isEmpty(this.patchData)) {
            const dataToSend = _.cloneDeep(this.patchData);
            Object.values(dataToSend).forEach((site: any) => {
                this.selectedSites[site.siteCode].data = this.patchData[
                    site.siteCode
                ].data;
                this.selectedSites[site.siteCode] = _.cloneDeep(
                    this.selectedSites[site.siteCode],
                );
                this.restructureDataForPopulation(dataToSend[site.siteCode]);
                delete dataToSend[site.siteCode].data;
            });
            this.siteBrowserService
                .updateWhitelistedSites(Object.values(dataToSend))
                .subscribe(
                    (response: any) => {
                        this.ToasterServiceInstace.ShowSuccess('Sites Saved Successfully.');
                        Object.values(this.patchData).forEach((site: any) => {
                            const filteredGridItemArray = _.filter(
                                this.gridData.data,
                                item => item.code === site.siteCode,
                            );
                            filteredGridItemArray.forEach(item => {
                                item.lastUpdatedDateTime = new Date();
                                item.lastUpdatedBy = this.ldap;
                            });
                            this.changeDetector.detectChanges();
                        });
                        this.setModifedData = {};
                        this.patchData = {};
                        this.canSave = false;
                        this.changeDetector.detectChanges();
                    },
                    (err: any) => {
                        this.ToasterServiceInstace.ShowError('Something Went wrong.');
                    },
            );
        }
    }

    public cancelSelection() {
        Object.values(this.setModifedData).forEach((site: any) => {
            site.data.pnsedit = false;
            site.data.pnsview = false;
            site.data.amview = false;
            site.data.amedit = false;
        });
        this.setModifedData = {};
        Object.values(this.patchData).forEach((site: any) => {
            const selectedSite = this.selectedSites[site.siteCode];
            this.setPermissionToSiteObject(selectedSite, site.data);
        });
        this.patchData = {};
        this.canSave = false;
        this.changeDetector.detectChanges();
    }
    private restructureDataForPopulation(cur: IWhitelistedSiteModel) {
        cur.ActivityMonitor = this.getPermisssionByApp(
            cur.permissions,
            FMPConstant.activityMonitor,
        );
        cur.PlanandSchedule = this.getPermisssionByApp(
            cur.permissions,
            FMPConstant.planandSchedule,
        );
        return cur;
    }
    private getPermisssionByApp(
        permissions: Array<ISitePermission>,
        app: string,
    ) {
        if (permissions) {
            return permissions.find(d => d.applicationName === app);
        }
    }
    private setPermissionToSiteObject(selectedSite, site) {
        site.pnsedit = this.getPermissionFlag(
            selectedSite,
            FMPConstant.planandSchedule,
            this.editPermision,
        );
        site.pnsview = this.getPermissionFlag(
            selectedSite,
            FMPConstant.planandSchedule,
            this.viewPermision,
        );
        site.amview = this.getPermissionFlag(
            selectedSite,
            FMPConstant.activityMonitor,
            this.viewPermision,
        );
        site.amedit = this.getPermissionFlag(
            selectedSite,
            FMPConstant.activityMonitor,
            this.editPermision,
        );
        site.apiEnabledForPnS = this.isApiEnabled(
            FMPConstant.planandSchedule,
            site,
        );
        site.apiEnabledForAM = this.isApiEnabled(FMPConstant.activityMonitor, site);
    }

    private isApiEnabled(appNames, site) {
        const dataToCheck = FMPConstant.apisenum[appNames];
        const siteWhitelistedFormMateo = this.allEnabledSites
            .filter(apis => dataToCheck.includes(apis.context))
            .reduce((acc, cur) => {
                return [...acc, ...cur.sites];
            }, [])
            .map((ctx: any) => ctx.siteCode);

        return !siteWhitelistedFormMateo.includes(site.code);
    }

    private getPermissionFlag(
        site: IWhitelistedSiteModel,
        app: string,
        permission: string,
    ) {
        return site && site[app] && site[app][permission];
    }

    ngOnDestroy() {
        this.siteApiErrorSubscription.unsubscribe();
        this.siteApiSubscription.unsubscribe();
    }

}
