/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */

import {
    Component, OnInit, OnDestroy, Input, 
    ChangeDetectorRef,
    OnChanges,

    AfterViewInit,
    ViewChild,
} from '@angular/core';
import { BaseComponent } from '../../../base/component/base/base.component';
import { EquipmentHealthService } from '../equipmenthealth/equipmenthealth.service';
import { LoggerService } from '../../../base/service/logger.service';
import { Equipment } from '../models/equipment-model';
import { EpisodicMeta } from '../episode/models/episodic-model';
import { EpisodeBrowserComponent } from '../episode/episodebrowser.component';
import { EpisodePointsComponent } from '../episode/episodepoints.component';
import { WorkOrderBrowserComponent } from '../workorder/workorderbrowser.component';
import { EquipmentChannelComponent } from '../equipmentchannel/equipmentchannel.component';

@Component({
    selector: 'digitalmaintpanel',
    templateUrl: './digitalmaintoverview.component.html',
    styleUrls: ['./digitalmaint.component.scss'],
})
export class DigitalMaintOverviewComponent extends BaseComponent implements OnInit, OnDestroy, OnChanges, AfterViewInit {

    @Input() incomingEquipment: Equipment = null;
    @Input() workorderList: any[] = [];
    // provide child references (so we can notify of changes)
    // this is fairly ugly and only used to call the refresh methods (instead of having to code up a new input for each one)
    @ViewChild(EpisodeBrowserComponent, { static: false }) episodeChildRef: EpisodeBrowserComponent;
    @ViewChild(EpisodePointsComponent, { static: false }) episodepointsChildRef: EpisodePointsComponent;
    @ViewChild(WorkOrderBrowserComponent, { static: false }) workordersChildRef: WorkOrderBrowserComponent;
    @ViewChild(EquipmentChannelComponent, { static: false }) channelsChildRef: EquipmentChannelComponent;
    selectedDigMaintEquipment: Equipment = null;
    selectedEpisodeID: string = null;
    public progressWindowOpened = false;
    outgoingLasJobId: string = null;
    defaultLasFilename: string = 'PHM_WL_XLROCK_MCMU - B_152_DEMO_CMPR_CMDV.zip';
    currentLasUploadJobId: string = '';
    currentLasCorrelationId: string = '';
    enableAvatarSim: boolean = false;
    totalRunHours: number = 0.0;

    constructor(
        loggerService: LoggerService,
        private changeDetector: ChangeDetectorRef,
        public equipmentHealthService: EquipmentHealthService,
    ) {
        super('DigitalMaintOverviewComponent', loggerService);
    }
    ngOnChanges() {

    }
    ngOnInit() {
        this.selectedDigMaintEquipment = this.incomingEquipment;
        this.WriteInfoLog('equipmentID = ' + this.selectedDigMaintEquipment.id);
        if (this.selectedDigMaintEquipment != null) {
            this.workorderList = this.selectedDigMaintEquipment.workorders;
            this.WriteInfoLog('found = ' + this.workorderList.length + ' work orders');
        }
    }
    public uploadFinished = (event) => {

        this.currentLasUploadJobId = event;
        this.ToasterServiceInstace.ShowInformation('jobID=' + this.currentLasUploadJobId);
        this.outgoingLasJobId = this.currentLasUploadJobId;
        //this.getStandardWorkDataAsObject("", "", "");
        this.lauchProgressModal();
    }
    onEpisodeSelectedEmission(incomingselectedEpisodeID: string) {

        this.selectedEpisodeID = incomingselectedEpisodeID;
    }
    onEpisodePointsEmission(incomingEpisodic: EpisodicMeta) {
  
        let episodicPoints: any[] = incomingEpisodic.rows;
        if (episodicPoints != null) {
            let totalHours: number = 0; // big assumption that these are hours TBD to fix after demo
         
                for (let i = 0; i < episodicPoints.length; i++) {

                    // NEED TO SEARCH FOR CORRECT INDEX OF THE ARRAY AND ALSO MAKE SURE ITS A NUMBER
                    // USE THE CHANNEL CODEs and .find to find one with code 'eMOT'
                    totalHours = totalHours + parseFloat(episodicPoints[i].eMotValue);
                }
            
            this.totalRunHours = totalHours;
        }
    }
    handleNotificationEvent(incomingMsg: any) {
        
        // need to call a refresh or trigger the change detector.
        this.WriteInfoLog('Maint Panel recieved a progress notfication ' + incomingMsg);
        if (incomingMsg.indexOf("channel data created") > -1) {
            this.channelsChildRef.refreshData();
        }
        if (incomingMsg.indexOf("episode was created") > -1) {
            this.episodeChildRef.refreshData();
        }
        if (incomingMsg.indexOf("eMot simulation completed") > -1) {
            this.episodepointsChildRef.refreshData();
        }
        if (incomingMsg.indexOf("work order created") > -1) {
            this.workordersChildRef.refreshData();
        }
        else if (incomingMsg.indexOf("refresh all") > -1) {
            this.channelsChildRef.refreshData();
            this.episodeChildRef.refreshData();
            this.workordersChildRef.refreshData();
            this.episodepointsChildRef.refreshData();
        }
  
    }
    lauchProgressModal() {
        this.WriteInfoLog('launching progress modal for job id ' + this.outgoingLasJobId );
        this.progressWindowOpened = true;
    }
    public close() {
        this.progressWindowOpened = false;
    }

    public open() {
        this.progressWindowOpened = true;
    }
    /**
 * This method is used to set the grid height dynamically
 *
 */
    onResize() {
        this.WriteDebugLog('DigitalMaintOverviewComponent => onResize');

    }
    /**
    * Manually Detaches the angular change detection.
    *
    */
    onCDDetach() {
        this.changeDetector.detach();
    }

    /**
     * Manually Re-attaches the angular change detection.
     *
     */
    onCDReAttach() {
        this.changeDetector.reattach();
        this.changeDetector.detectChanges();
    }

    ngAfterViewInit() {
        this.WriteDebugLog('DigitalMaintOverviewComponent => ngAfterViewInit');

    }


    // These are node items that can be any level... not really Groups.
    // We should change this to a more appropriate node type
    public handleSingleSelectionFromTree(event): void {

    }
    // These emitted items are row items from Grid and always  
    public handleMultiSelectionFromGrid(event): void {




    }
 
    /**
     * We are clearing everything here
     */
    ngOnDestroy() {

    }
    // for grid, we need to flatten out the hiearchy and create a new row for every leaf
    
}
