/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */

import {
    Component, OnInit, OnDestroy, Input, 
    ChangeDetectorRef,
    OnChanges,

    AfterViewInit,
    EventEmitter,
    Output,
    ViewChild,
    ElementRef,
    AfterViewChecked,
} from '@angular/core';
import { BaseComponent } from '../../../base/component/base/base.component';
import { LoggerService } from '../../../base/service/logger.service';
import { Equipment } from '../models/equipment-model';
import { StatusList, StatusPoint, ODMEquipEventStatus, ODMPoint, WORequestStatus } from './models/progress-model';
import { ProgressPanelService } from './progresspanel.service';
import { Subscription, interval } from 'rxjs';
import { WorkOrderService } from '../workorder/workorder.service';

@Component({
    selector: 'progresspanel',
    templateUrl: './progresspanel.component.html',
    styleUrls: [ './progresspanel.component.scss'],
})
export class ProgressPanelComponent extends BaseComponent implements OnInit, OnDestroy, OnChanges, AfterViewInit, AfterViewChecked {


    @Input() incomingEquipment: Equipment = null;
    @Input() incomingLASJobID: string = null;
    @Input() incomingEnableAvatarSim: boolean = false;
    @Output() notificationEvent = new EventEmitter<any>();
    @ViewChild('scrollMe', { static: false }) private scrollMe: ElementRef;
    selectedDigMaintEquipment: Equipment = null;
    selectedEpisodeID: string = null;
    correlationID: string = 'ffe8fbd7-7bc1-4b52-802e-6c93ddbc668d';// hardocded for now
    jobId: string = '2069157198-2020-01-15-21-30-13-075';//hardcoded until we get the job id from las file uploader.
    lasFileStatus: string = 'lastest';
    delfiStatus: string = 'dtest';
    ehcAgentStatus: string = 'etest';
    avatarStatus: string = '';
    ehcHistorianStatus: string = 'htest';
    odmStatus: string = 'otest';
    cmmsStatus: string = 'ctest';
    lasFileStatusColor: string = '';
    delfiStatusColor: string = '';
    ehcAgentStatusColor: string = '';
    avatarStatusColor: string = '';
    ehcHistorianStatusColor: string = '';
    odmStatusColor: string = '';
    cmmsStatusColor: string = '';
    ehcAgentCompleted: boolean = false;
    episodeIDCreatedFromEHC: string = null;
    workOrderRequested: boolean = false;
    workOrderConfirmed: boolean = false;
    workOrderRequestId: string = null;
    delfiAgentCompleted: boolean = false;
    odmAgentCompleted: boolean = false;
    avatarStarted: boolean = false;
    avatarCompleted: boolean = false; 
    delfiStatusList: StatusPoint[] = [];
    ehcStatusList: StatusPoint[] = [];
    refreshStopped: boolean = false;
    odmEquipEventStatus: ODMEquipEventStatus = null;
    lasFileName: string = '';
    a2rStatus: WORequestStatus = null;
    a2rCompleted: boolean = false;
    testMessages = new Array<StatusPoint>(300);
    testMessageCounter: number = 0;
    disableScrollDown = false
    // for the kendo progr bar
    public progvalue = 3;
    public min = 0;
    public max = 8;
    public chunks = 8;
    //public completeness = '5%';

    private updateSubscription: Subscription;
    startTime: Date;
    endTime: Date;


    constructor(
        loggerService: LoggerService,
        private changeDetector: ChangeDetectorRef,
        public progressPanelService: ProgressPanelService,
        public workOrderService: WorkOrderService,
    ) {
        super('ProgressPanelComponent', loggerService);
    }
    ngOnChanges() {

    }
    clearStatus() {
        this.lasFileStatus = '';
        this.delfiStatus = '';
        this.ehcAgentStatus = '';
        this.avatarStatus = '';
        this.ehcHistorianStatus = '';
        this.odmStatus = '';
        this.cmmsStatus = '';
        this.lasFileStatusColor = 'black';
        this.delfiStatusColor = 'black';
        this.ehcAgentStatusColor = 'black';
        this.avatarStatusColor = 'black';
        this.ehcHistorianStatusColor = 'black';
        this.odmStatusColor = 'black';
        this.cmmsStatusColor = 'black';
    }
    scrollToBottom(): void {
        try {
            if (this.disableScrollDown) {
                return
            }
            this.scrollMe.nativeElement.scrollTop = this.scrollMe.nativeElement.scrollHeight;
        } catch (err) { }
    }
    onScroll() {
        let element = this.scrollMe.nativeElement;
        let atBottom = element.scrollHeight - element.scrollTop === element.clientHeight
        if (atBottom) {
            this.disableScrollDown = false;
        } else {
            this.disableScrollDown = true;
        }
    }
    ngOnInit() {
        this.selectedDigMaintEquipment = this.incomingEquipment;
        super.WriteInfoLog('equipmentID = ' + this.selectedDigMaintEquipment.id);
        super.WriteInfoLog('Las JobID = ' + this.incomingLASJobID);
        this.lasFileStatus = this.incomingLASJobID + ' tracking started...';
        this.progvalue = 0;
        this.updateSubscription = interval(5000).subscribe(
            (val) => {
                this.refreshProgress();
            }
        );
        this.scrollToBottom();
    }
    ngAfterViewChecked() {
        this.scrollToBottom();
    } 
    onEpisodeSelectedEmission(incomingselectedEpisodeID: string) {

        this.selectedEpisodeID = incomingselectedEpisodeID;
    }
    refreshProgress() {
        if (this.incomingLASJobID != null) {
            this.getUploadStatus();
            this.getEHCStatus();
            this.checkForAvatarLaunch();
            this.getODMStatus();
            this.getA2RRequestStatus();
            this.checkForNewWorkOrder();
            //this.generateTestScroll();
        }
    }
    // softer is 669bc6
    public progressStyle: { [key: string]: any } = {
        background: '#1683fb'
    };

    public emptyStyle: { [key: string]: any } = {
        background: '#d1d6de'
    };
    stopRefresh() {
        setTimeout(() => this.updateSubscription.unsubscribe(), 2000);
        this.refreshStopped = true;
    }
    startRefresh() {
        this.refreshStopped = false;      
        this.updateSubscription = interval(5000).subscribe(
            (val) => {
                this.refreshProgress();
            }
        );
    }
    /**
 * This method is used to set the grid height dynamically
 *
 */
    onResize() {
        super.WriteDebugLog('ProgressPanelComponent => onResize');

    }
    /**
    * Manually Detaches the angular change detection.
    *
    */
    onCDDetach() {
        this.changeDetector.detach();
    }

    /**
     * Manually Re-attaches the angular change detection.
     *
     */
    onCDReAttach() {
        this.changeDetector.reattach();
        this.changeDetector.detectChanges();
    }

    ngAfterViewInit() {
        super.WriteDebugLog('ProgressPanelComponent => ngAfterViewInit');

    }
    incrementProg() {
        this.progvalue++;
    }
    generateTestScroll() {
       
        // scroll test block
       
            this.testMessages[this.testMessageCounter] = {
                timestamp: new Date(),
                status: "another message to test scrolling",
        }
        this.testMessageCounter++;
        this.scrollToBottom();
        
    }
    getUploadStatus() {

        if (this.progvalue == 0) {
            this.progvalue = 1;
            this.startTime = new Date();
        }
            if (this.delfiAgentCompleted) return;
        this.progressPanelService.checkUploadJobStatus(this.incomingLASJobID).subscribe(
            incomingResponse => {
                
                // start looking for correlation ID
                if (incomingResponse && incomingResponse.status && incomingResponse.status.jobStatus && incomingResponse.status.jobStatus.length > 0) {

                    this.lasFileName = incomingResponse.status.fileName;
                    if (this.progvalue == 0) this.progvalue = 1;
                    this.delfiStatusList = new Array<StatusPoint>(incomingResponse.status.jobStatus.length);
                    for (let i = 0; i < incomingResponse.status.jobStatus.length; i++) {
                        this.lasFileStatus = incomingResponse.status.jobStatus[i].status;
                        this.delfiStatusList[i] = {
                            timestamp: incomingResponse.status.jobStatus[i].timestamp,
                            status: incomingResponse.status.jobStatus[i].status
                        }
                        //this.ToasterServiceInstace.ShowInformation(this.lasFileStatus);
                    }
                    this.scrollToBottom();
                }
                if (incomingResponse && incomingResponse.status && incomingResponse.status.taskStatus && incomingResponse.status.taskStatus.length > 0) {

                    this.correlationID = incomingResponse.status.taskStatus[0]["slb-correlation-id"];

                    // now append additional task status's
                    let tmpTaskStatusList: StatusPoint[] = new Array<StatusPoint>(incomingResponse.status.taskStatus[0].status.length);
                    for (let i = 0; i < incomingResponse.status.taskStatus[0].status.length; i++) {

                        this.lasFileStatus = incomingResponse.status.taskStatus[0].status[i].status;

                        //this.ToasterServiceInstace.ShowInformation(this.lasFileStatus);
                        tmpTaskStatusList[i] = {
                            timestamp: incomingResponse.status.taskStatus[0].status[i].timestamp,
                            status: incomingResponse.status.taskStatus[0].status[i].status
                        }
                        if (tmpTaskStatusList[i].status.indexOf("Logset record generated and saved") > -1) {
                            if (this.progvalue == 1) this.progvalue = 2;
                        }
                        if (tmpTaskStatusList[i].status.indexOf("message published") > -1) {
                            if (this.progvalue == 2) this.progvalue = 3;
                        }
                        if (tmpTaskStatusList[i].status.indexOf("ingestion completed") > -1) {
                            this.delfiAgentCompleted = true;
                        }
                    }
         
                    this.delfiStatusList.push(...tmpTaskStatusList);
                    // now that we have as correlationID, go get the  ehc agent status
                    this.scrollToBottom();
                   
                }
                else {
                    //this.ToasterServiceInstace.ShowInformation('no status for ' + this.jobId);
                }
            },

        );
    }
    getEHCStatus() {

        // only check if needed
        if (!this.delfiAgentCompleted || this.ehcAgentCompleted) return;

        if (this.correlationID != null && this.correlationID.length > 0) {
            this.WriteInfoLog("status for correlationID " + this.correlationID + " being retrieved from EHC agent...");
            this.progressPanelService.checkEHCAgentStatus(this.correlationID).subscribe(
                incomingStatus => {

                    if (incomingStatus && incomingStatus.length > 0) {

                        this.ehcStatusList = new Array<StatusPoint>(incomingStatus.length);
                        for (let i = 0; i < incomingStatus.length; i++) {
                            //this.ToasterServiceInstace.ShowInformation(incomingStatus[i].status);
                            this.ehcStatusList[i] = {
                                timestamp: incomingStatus[i].timestamp,
                                status: incomingStatus[i].status
                            }
                            
                            if (this.ehcStatusList[i].status.indexOf("Sending channel data") > -1) {
                                if (this.progvalue == 3) this.progvalue = 4;
             
                            }
                            if (this.ehcStatusList[i].status.indexOf("episode was created") > -1) {
                                this.ehcAgentCompleted = true;
                                let tmpID = this.ehcStatusList[i].status.substring(this.ehcStatusList[i].status.indexOf(":")+2);// the plus 2 is to get rid of colon and scpace before id
                                this.episodeIDCreatedFromEHC = tmpID;
                                if (this.progvalue == 4) this.progvalue = 5;
                                this.notificationEvent.emit("episode data created.");
                                this.notificationEvent.emit("channel data created"); // just doing this once at the end because
                            }
                            
                        }
                        this.scrollToBottom();
                    }
                    else {
                        //this.ToasterServiceInstace.ShowInformation('no status for ' + this.jobId);
                    }
                    
                },
                error => {
                    this.WriteInfoLog('error in getEHCStatus', error);
                    
                },
            );
        }
    }
    checkForAvatarLaunch() {
        if (this.avatarStarted || !this.incomingEnableAvatarSim || this.avatarCompleted ||  !this.ehcAgentCompleted) return;

        if (this.incomingEnableAvatarSim && !this.avatarCompleted) {
            if (this.episodeIDCreatedFromEHC != null) {
                // launch avatar
                this.avatarStarted = true;
                this.avatarStatus = "launching local eMot calculation ...";
                this.ToasterServiceInstace.ShowInformation('running Emot Simulation for id: ' + this.episodeIDCreatedFromEHC );
                this.WriteInfoLog('running Avatar Simulation for id: ' + this.episodeIDCreatedFromEHC );
          
                this.progressPanelService.processEmotEpisode(this.episodeIDCreatedFromEHC, this.incomingEquipment.wellKnownEntityId, this.correlationID).subscribe(
                    incomingEpisodeResponseMsg => {

                        this.WriteInfoLog(incomingEpisodeResponseMsg.toString());
                        if (incomingEpisodeResponseMsg == "Success")// suspect
                        {
                            this.ToasterServiceInstace.ShowSuccess('processed Emot successfully');
                            this.avatarStatus = "Emot processed successfully by eMot simulation.";
                            this.avatarCompleted = true;
                            this.notificationEvent.emit("eMot simulation completed");
                        }
                      
                    },
                    error => {
                        this.WriteErrorLog('error in checkForAvatarLaunch', error);
                       // this.ToasterServiceInstace.ShowError('Something went wrong running local Avatar.');
                        this.avatarCompleted = true;
                    },
                );
            }
        }
    }
    getODMStatus() {

        // only check if needed
        if (!this.ehcAgentCompleted || this.odmAgentCompleted || (this.incomingEnableAvatarSim && !this.avatarCompleted)) return;

        if (this.correlationID != null && this.correlationID.length > 0) {
            this.WriteInfoLog("status for correlationID " + this.correlationID + " being retrieved from ODM server...");
            this.progressPanelService.checkEquipEventStatus(this.correlationID).subscribe(
                incomingStatus => {

                    if (incomingStatus) {
          
                        this.odmEquipEventStatus = incomingStatus;
                        // look for completion
                        if (incomingStatus.details != null) {
                            for (let i = 0; i < incomingStatus.details.length; i++) {

                                if (incomingStatus.details[i].message.indexOf("Finished ODM Calculation") > -1) {
                                    if (this.progvalue == 5) this.progvalue = 6;
                                }
                                if (incomingStatus.details[i].message.indexOf("Work Order requested") > -1) {
                                    this.workOrderRequested = true;
                                    // get request tracker id
                                    let tmpId: string = incomingStatus.details[i].message.substring(incomingStatus.details[i].message.indexOf(":") + 3);
                                    this.workOrderRequestId = tmpId;
                                    if (this.progvalue == 6) this.progvalue = 7;
                                }
                                else if (incomingStatus.details[i].message.indexOf("New work order needed:  FALSE") > -1) {
                                    this.workOrderRequested = false;
                      
                                    this.progvalue = 8;
                                    this.a2rCompleted = true;
                                    this.endTime = new Date();
                                   
                                }
                                if (incomingStatus.details[i].message.indexOf("Finished ODM Processing") > -1) {
                                    this.odmAgentCompleted = true;
                                    this.notificationEvent.emit("episode data created."); // just to ensure we catch all the episodes which may have been created late
                                }
                            }
                            this.scrollToBottom();
                        }
                    }
                    else {
                        //this.ToasterServiceInstace.ShowInformation('no status for ' + this.jobId);
                    }
                },
                error => {
                    this.WriteErrorLog('error in getEHCStatus', error);

                },
            );
        }

    }
    getA2RRequestStatus() {

        // only check if needed
        if (this.a2rCompleted || !this.workOrderRequested || this.workOrderRequestId == null ) return;


        this.workOrderService.getRequestStatus(this.workOrderRequestId).subscribe(
            requestStatus => {

                if (requestStatus) {

                    this.a2rStatus = requestStatus;
                    if (requestStatus.errors != null && requestStatus.errors.length > 0)
                    {
                        for (let i = 0; i < requestStatus.errors.length; i++) {

                            if (requestStatus.errors[i].detail.indexOf("already on an open work order") > -1) {
                                if (this.progvalue == 7) this.progvalue = 8;
                                this.a2rCompleted = true;
                                this.endTime = new Date();
                                this.a2rStatus.currentStatus = "Equipment already has open work order. No new order created."
                            }
                            // need to see what the succesful message looks like so I can look at that.
                           // TBD

                        }
                        this.scrollToBottom();
                    }

                }
            },
            error => {
                this.WriteErrorLog('error in getA2RStatus', error);

            },
        );
    }
    checkForNewWorkOrder() {

        // only check if needed
        if (this.a2rCompleted || !this.workOrderRequested || this.workOrderConfirmed) return;


        this.workOrderService.getWorkOrdersByEquipmentWKE(this.incomingEquipment.wellKnownEntityId).subscribe(
            newEquipmentWithWOs => {

                if (newEquipmentWithWOs) {

                    // look at included workorder count and see if it is higher than when we started (crude) but should work for demo
                    let oldWOCount: number = 0;
                    if (this.incomingEquipment.workorders != null) {
                        oldWOCount = this.incomingEquipment.workorders.length;
                    }

                    let newWOCount: number = 0;

                    if (newEquipmentWithWOs.collection[0].workorders != null) {
                        newWOCount = newEquipmentWithWOs.collection[0].workorders.length;
                    }

                    if (newWOCount > oldWOCount) {
                        if (this.progvalue == 7) this.progvalue = 8;
                        this.workOrderConfirmed = true;
                        this.notificationEvent.emit("work order created");
                        this.endTime = new Date();
                        this.stopRefresh();
                    }
                    this.scrollToBottom();
                }
            },
            error => {
                this.WriteErrorLog('error in getA2RStatus', error);

            },
         );
    }

    
 
    /**
     * We are clearing everything here
     */
    ngOnDestroy() {
        this.updateSubscription.unsubscribe();
    }
    // for grid, we need to flatten out the hiearchy and create a new row for every leaf
    
}
