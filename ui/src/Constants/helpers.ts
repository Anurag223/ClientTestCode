/* Schlumberger Private
Copyright 2018 Schlumberger.  All rights reserved in Schlumberger
authored and generated code (including the selection and arrangement of
the source code base regardless of the authorship of individual files),
but not including any copyright interest(s) owned by a third party
related to source code or object code authored or generated by
non-Schlumberger personnel.

This source code includes Schlumberger confidential and/or proprietary
information and may include Schlumberger trade secrets. Any use,
disclosure and/or reproduction is prohibited unless authorized in
writing. */
import * as moment from 'moment';
import {
  EnvironmentSettings,
  AuthenticationSettings,
  IFMPRouteDetails,
  IUOMDetails,
  TempratureUnits,
  PressureUnits,
} from '../Constants/application';
import { Injector } from '@angular/core';
import * as momenttimezone from 'moment-timezone';

export const UnitOfMeasurements: IUOMDetails = {
  Default: {
    Name: 'Default',
    Temprature: TempratureUnits.KELVIN,
    Pressure: PressureUnits.ATM,
  },
  Imperial: {
    Name: 'Imperial',
    Temprature: TempratureUnits.FAHRENHEIT,
    Pressure: PressureUnits.PSI,
  },
  Metric: {
    Name: 'Metric',
    Temprature: TempratureUnits.CELCIUS,
    Pressure: PressureUnits.BAR,
  },
  SI: {
    Name: 'SI',
    Temprature: TempratureUnits.KELVIN,
    Pressure: PressureUnits.PASCAL,
  },
};

// FIX THIS!!!! - it referencss Iroutes defined in application.ts... should not have constants split into different files and areas of app!
export const RouteConfigPaths: IFMPRouteDetails = {
  AutoLogin: { name: 'auto-login', path: '/auto-login' },
  Home: { name: 'home', path: '/home' },
  Logout: { name: 'logout', path: '/logout' },
  Dashboard: { name: 'dashboard', path: '/dashboard' },
  PlanningAndScheduling: { name: 'equipment', path: '/equipment' },
  WorkCenter: { name: 'workcenter', path: '/workcenter' },
  ActivityMonitor: { name: 'activitymonitor', path: '/activitymonitor' },
  ReleaseNotes: { name: 'release-notes', path: '/release-notes' },
  FMPError: { name: 'error', path: '/error' },
  Forbidden: { name: 'forbidden', path: '/forbidden' },
  NotFound: { name: 'not-found', path: '/not-found' },
  UnAuthorized: { name: 'unauthorized', path: '/unauthorized' },
  Language: { name: 'language', path: '/language' },
  Administration: { name: 'administration', path: '/administration' },
  HistorianProvision: { name: 'historianprovision', path: '/historianprovision' },
  EpisodeBrowser: { name: 'episodebrowser', path: '/episodebrowser' },
  EpicV3Browser: { name: 'epicv3browser', path: '/epicv3browser' },
  ClassificationEditor: { name: 'classificationeditor', path: '/classificationeditor' },
  StandardWork: { name: 'standardwork', path: '/standardwork' },
  EquipmentHealth: { name: 'equipmenthealth', path: '/equipmenthealth' },
  DataMappingUtils: { name: 'datamapping', path: '/datamapping' },
  SchedulerAdmin: { name: 'scheduleradmin', path: '/scheduleradmin' },
  HistorianManagement: { name: 'historianmanagement', path: '/historianmanagement' },
  ConflictManagement: { name: 'conflictmanagement', path: '/conflictmanagement' },
  AddSchedulerJob: { name: 'addschedulerjob', path: '/scheduleradmin/addschedulerjob' },
  UpdateSchedulerJob: { name: 'updateschedulerjob', path: '/scheduleradmin/updateschedulerjob' },
  AuditLog:{name: 'auditlogging', path: '/auditlogging'},
  ChannelDefinition:{name: 'channeldefinition', path: '/channeldefinition'},
  ChannelDefinitionAdmin:{name:'channeldefinitionadmin',path:'/channeldefinitionadmin'}
};

export class FMPHelper {
  static AngularInjector: Injector;

  // TODO: move method to env.service.ts
  static appSettings: EnvironmentSettings;
  public static get ApplicationSettings(): EnvironmentSettings {
    const globalThis: any = window || { __env: {} };
    const env = globalThis.__env;
    return FMPHelper.appSettings
      ? FMPHelper.appSettings
      : new EnvironmentSettings(env.baseUrls);
  }

  // TODO: move method to env.service.ts
  static authSettings: AuthenticationSettings;
  public static get AuthenticationSettings(): AuthenticationSettings {
    const globalThis: any = window || { __env: {} };
    const env = globalThis.__env;
    return FMPHelper.authSettings
      ? FMPHelper.authSettings
      : new AuthenticationSettings(env.authenticationConfiguration);
  }

  public static get Routes(): IFMPRouteDetails {
    return RouteConfigPaths;
  }

  public static get CurrentTimeZone(): string {
    return /\((.*)\)/.exec(new Date().toString())[1];
  }

  public static get CurrentTimeZoneWithOffset(): string {
    const zoneName = momenttimezone.tz.guess();
    const timezone = momenttimezone.tz(zoneName).zoneAbbr();
    const offset = momenttimezone.tz(zoneName).format('Z');
    return timezone + ' - ' + this.CurrentTimeZone + ' (' + offset + ')';
  }

  public static ConvertToLocalDate(inputDate: any): Date {
    if (inputDate && inputDate[inputDate.length - 1] === 'z') {
      inputDate = inputDate.substring(0, inputDate.length - 1) + 'Z';
      return new Date(inputDate);
    } else if (inputDate && inputDate[inputDate.length - 1] !== 'Z') {
      inputDate = inputDate + 'Z';
      return new Date(inputDate);
    }
    return inputDate ? new Date(inputDate) : inputDate;
  }

  /**
   * ConvertTimeZone is used to conveting time from one time zone to another
   */
  public static ConvertTimeZone(
    inputDate: string,
    fromTZ: string,
    toTZ: string,
  ): Date {
    const sourceZonedTime = momenttimezone.tz(inputDate, fromTZ);
    const targetZonedTime = sourceZonedTime.clone().tz(toTZ);
    return new Date(moment(targetZonedTime).format('DD-MMM-YYYY HH:mm'));
  }

  /**
   * It gives current date in UTC
   */
  public static get CurrentUTCDate(): Date {
    return new Date(new Date().toUTCString().slice(0, -3));
  }

  /**
   * It gives current local date
   */
  public static get CurrentLocalDate(): Date {
    return new Date();
  }

  // Retruns if second string is part of the first string or both are null/undefined.
  public static StringContains(
    firstValue: string,
    secondValue: string,
    matchcase?: boolean,
  ): boolean {
    // Retrun true is both values are null or undefined.
    let returnValue = !firstValue && !secondValue;
    if (firstValue && secondValue) {
      // If both values exist compare the two values
      if (!matchcase) {
        firstValue = firstValue.trim().toLowerCase();
        secondValue = secondValue.trim().toLowerCase();
      }
      returnValue = firstValue.indexOf(secondValue) !== -1;
    }
    return returnValue;
  }

  /**
   * Here string equal logic is implemented to check 2 strings are equal ir not.
   */
  public static StringEqual(firstValue: string, secondValue: string): boolean {
    // Retrun true is both values are null or undefined.
    let returnValue = !firstValue && !secondValue;
    if (firstValue && secondValue) {
      // If both values exist compare the two values
      firstValue = firstValue.trim().toLowerCase();
      secondValue = secondValue.trim().toLowerCase();
      returnValue = firstValue === secondValue;
    }
    return returnValue;
  }

  public static ObjectEqual(firstValue: any, secondValue: any): boolean {
    // Retrun true is both values are null or undefined.
    let returnValue = !firstValue && !secondValue;
    if (firstValue && secondValue) {
      // If both values exist compare the two values
      firstValue = firstValue
        .toString()
        .trim()
        .toLowerCase();
      secondValue = secondValue
        .toString()
        .trim()
        .toLowerCase();
      returnValue = firstValue === secondValue;
    }
    return returnValue;
  }

  public static CloneJSONObject<T>(obj: T): T {
    if (obj) {
      const jsonString: string = JSON.stringify(obj);
      return JSON.parse(jsonString) as T;
    }
    return null;
  }

  public static StringIsNullOrWhiteSpace(value: string): boolean {
    if (!value) {
      return true;
    } else {
      value = value.trim();
      return value.length === 0;
    }
  }

  public static FormatDate(value: Date, dateformat: string): string {
    return moment(value.toLocaleString().replace(/[^ -z]/g, '')).format(
      dateformat,
    );
  }

  public static ExtractValueFromObject(object: any, fieldPath: string): any {
    let returnValue: any;
    try {
      if (object && !FMPHelper.StringIsNullOrWhiteSpace(fieldPath)) {
        const fieldNames = fieldPath.split('.');
        if (fieldNames && fieldNames.length > 0) {
          let tempValue = object;
          for (const field of fieldNames) {
            tempValue = tempValue[field];
            if (!tempValue) {
              break;
            }
          }
          returnValue = tempValue;
        }
      }
    } catch (ex) {
      console.log(ex);
    }
    return returnValue;
  }

  public static ReadFromLocalStorage(key: string): any {
    const data = localStorage.getItem(key);
    if (data) {
      return JSON.parse(data);
    }
    return;
  }

  public static WriteToLocalStorage(key: string, value: any): void {
    localStorage.setItem(key, JSON.stringify(value));
  }

  public static ReadFromSessionStorage(key: string): any {
    const data = sessionStorage.getItem(key);
    if (data) {
      return JSON.parse(data);
    }
    return;
  }

  public static WriteToSessionStorage(key: string, value: any): void {
    sessionStorage.setItem(key, JSON.stringify(value));
  }

  /**
   * This method is used to make temperature conversions
   */
  public static convertTemparature(
    from: TempratureUnits,
    to: TempratureUnits,
    value: string,
  ): string {
    // If the Value is null or empty then  return the value as is, else proceed with the conversions
    if (FMPHelper.StringIsNullOrWhiteSpace(value)) {
      return value;
    } else if (from === to) {
      // If the source and target format is same then no conversions are required
      // and we simply format the number of digits after decimal to 3
      const tempNumber = Number.parseFloat(value);
      return tempNumber.toFixed(3);
    } else {
      // if source format and target format are different then we need to make the conversions
      let tempNumber = Number.parseFloat(value);
      switch (from) {
        case TempratureUnits.KELVIN:
          //#region  Convert from Kelvin
          switch (to) {
            case TempratureUnits.CELCIUS:
              tempNumber = tempNumber - 273.15;
              break;
            case TempratureUnits.FAHRENHEIT:
              tempNumber = (tempNumber - 273.15) * (9 / 5) + 32;
              break;
          }
          //#endregion
          break;
        case TempratureUnits.CELCIUS:
          //#region  Convert from Celcius
          switch (to) {
            case TempratureUnits.KELVIN:
              tempNumber = tempNumber + 273.15;
              break;
            case TempratureUnits.FAHRENHEIT:
              tempNumber = tempNumber * (9 / 5) + 32;
              break;
          }
          //#endregion
          break;
        case TempratureUnits.FAHRENHEIT:
          //#region  Convert from Fahrenheit
          switch (to) {
            case TempratureUnits.KELVIN:
              tempNumber = (tempNumber - 32) * (5 / 9) + 273.15;
              break;
            case TempratureUnits.CELCIUS:
              tempNumber = (tempNumber - 32) * (5 / 9);
              break;
          }
          //#endregion
          break;
      }

      return tempNumber.toFixed(3);
    }
  }

  /**
   * This method is used to make pressure conversions
   */
  public static convertPressure(
    from: PressureUnits,
    to: PressureUnits,
    value: string,
  ): string {
    // If the Value is null or empty then  return the value as is, else proceed with the conversions
    if (FMPHelper.StringIsNullOrWhiteSpace(value)) {
      return value;
    } else if (from === to) {
      // If the source and target format is same then no conversions are required
      // and we simply format the number of digits after decimal to 3
      const pressureValue = Number.parseFloat(value);
      return pressureValue.toFixed(3);
    } else {
      // if source format and target format are different then we need to make the conversions
      let pressureValue = Number.parseFloat(value);

      switch (from) {
        case PressureUnits.PSI:
          //#region  Convert from PSI
          switch (to) {
            case PressureUnits.ATM:
              pressureValue = pressureValue / 14.696;
              break;
            case PressureUnits.BAR:
              pressureValue = pressureValue / 14.504;
              break;
            case PressureUnits.PASCAL:
              pressureValue = pressureValue * 6894.757;
              break;
          }
          //#endregion
          break;
        case PressureUnits.ATM:
          //#region  Convert from ATM
          switch (to) {
            case PressureUnits.PSI:
              pressureValue = pressureValue * 14.696;
              break;
            case PressureUnits.BAR:
              pressureValue = pressureValue * 1.013;
              break;
            case PressureUnits.PASCAL:
              pressureValue = pressureValue * 101325;
              break;
          }
          //#endregion
          break;
        case PressureUnits.BAR:
          //#region  Convert from BAR
          switch (to) {
            case PressureUnits.ATM:
              pressureValue = pressureValue / 1.013;
              break;
            case PressureUnits.PSI:
              pressureValue = pressureValue * 14.504;
              break;
            case PressureUnits.PASCAL:
              pressureValue = pressureValue * 100000;
              break;
          }
          //#endregion
          break;
        case PressureUnits.PASCAL:
          //#region  Convert from PASCAL
          switch (to) {
            case PressureUnits.ATM:
              pressureValue = pressureValue / 101325;
              break;
            case PressureUnits.BAR:
              pressureValue = pressureValue / 100000;
              break;
            case PressureUnits.PSI:
              pressureValue = pressureValue / 6894.757;
              break;
          }
          //#endregion
          break;
      }

      return pressureValue.toFixed(3);
    }
  }
}
